{
  "version": 3,
  "file": "main.js",
  "sources": [
    "../../node_modules/@jsenv/pwa/src/internal/listenEvent.js",
    "../../node_modules/@jsenv/pwa/src/listenAppInstalled.js",
    "../../node_modules/@jsenv/pwa/src/displayModeStandalone.js",
    "../../node_modules/@jsenv/pwa/src/add-to-home-screen.js",
    "../../node_modules/@jsenv/core/helpers/babel/arrayLikeToArray/arrayLikeToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/toConsumableArray/toConsumableArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/arrayWithoutHoles/arrayWithoutHoles.js",
    "../../node_modules/@jsenv/core/helpers/babel/iterableToArray/iterableToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/unsupportedIterableToArray/unsupportedIterableToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/nonIterableSpread/nonIterableSpread.js",
    "../../node_modules/@jsenv/pwa/src/navigatorController.js",
    "../../node_modules/@jsenv/pwa/src/internal/createSignal.js",
    "../../node_modules/@jsenv/pwa/src/internal/sendMessageUsingChannel.js",
    "../../src/pwa/add-to-home-screen.js",
    "../../src/pwa/service-worker-update.js",
    "../../src/pwa/service-worker-registration.js",
    "../../src/greet.js",
    "../../src/app.js"
  ],
  "sourcesContent": [
    "export const listenEvent = (objectWithEventEmitter, event, callback) => {\n  objectWithEventEmitter.addEventListener(event, callback)\n  return () => {\n    objectWithEventEmitter.removeEventListener(event, callback)\n  }\n}\n",
    "/**\n * - User can decide by himself to install the application from the browser toolbar.\n * - Or application code is allowed to prompt user to do so on a user interaction such\n * as after clicking on a button.\n * In these scenarios when user clicks install on that prompt displayed by the browser,\n * browser dispatch an \"appinstalled\" event.\n */\n\nexport const listenAppInstalled = (callback) => {\n  window.addEventListener(\"appinstalled\", callback)\n  return () => {\n    window.removeEventListener(\"appinstalled\", callback)\n  }\n}\n\n// listenAppInstalled(() => {\n//   document.querySelector(\"#install\").disabled = true\n// })\n",
    "/**\n * displayModeStandalone can be used to know the current displayMode of\n * our web page is standalone (PWA)\n */\n\nexport const displayModeStandalone = {\n  get: () => window.navigator.standalone || window.matchMedia(\"(display-mode: standalone)\").matches,\n  listen: (callback) => {\n    const media = window.matchMedia(\"(display-mode: standalone)\")\n    media.addListener(callback)\n    return () => {\n      media.removeListener(callback)\n    }\n  },\n}\n",
    "/**\n  The following scenario is working:\n\n  - user click install button -> browser shows add to home screen prompt\n  - user click cancel on browser prompt\n  - user click again install button -> browser shows again add to home screen prompt\n\n  It's very easy to break this so that subsequent click does nothing.\n  Nothing means browser always returns a \"dimissed\" user choice without asking user.\n  I suspect chrome is trying to prevent malicious script to annoy user\n  by calling prompt() many times.\n\n  It's currently working because we don't hide beforeinstallpromptEvent behind a function.\n  It would be hidden behind a function if we put it into react state or\n  just by using a curried funciton like:\n\n  beforeinstallpromptEvent\n  const curriedFunction = () => {\n    beforeinstallpromptEvent.prompt()\n  }\n\n  If we do so, chrome will always dismiss subsequent click on install button. (until page is reloaded).\n  To avoid that we store the event on window.beforeinstallpromptEvent.\n*/\n\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { listenAppInstalled } from \"./listenAppInstalled.js\"\nimport { displayModeStandalone } from \"./displayModeStandalone.js\"\n\nlet appInstalledEvent = false\n\nlistenAppInstalled(() => {\n  // prompt \"becomes\" unavailable if user installs app\n  // it can happen if user installs app manually from browser toolbar\n  // in that case there is no point showing the install\n  // button in the ui\n  appInstalledEvent = true\n})\n\nexport const addToHomescreen = {\n  isAvailable: () => {\n    if (!window.beforeinstallpromptEvent) {\n      return false\n    }\n\n    if (displayModeStandalone.get()) {\n      return false\n    }\n\n    if (appInstalledEvent) {\n      return false\n    }\n\n    return true\n  },\n\n  listenAvailabilityChange: (callback) => {\n    let availablePrevious = addToHomescreen.isAvailable()\n\n    const checkAvailabilityChange = () => {\n      const available = addToHomescreen.isAvailable()\n      if (available !== availablePrevious) {\n        availablePrevious = available\n        callback(available)\n      }\n    }\n\n    const removeBeforeInstallPromptListener = listenBeforeInstallPrompt(\n      (beforeinstallpromptEvent) => {\n        window.beforeinstallpromptEvent = beforeinstallpromptEvent\n        checkAvailabilityChange()\n      },\n    )\n\n    const removeDisplayModeListener = displayModeStandalone.listen(() => {\n      checkAvailabilityChange()\n    })\n\n    const removeAppInstalledListener = listenAppInstalled(() => {\n      // prompt \"becomes\" unavailable if user installs app\n      // it can happen if user installs app manually from browser toolbar\n      // in that case there is no point showing the install\n      // button in the ui\n      appInstalledEvent = true\n      checkAvailabilityChange()\n    })\n\n    return () => {\n      removeBeforeInstallPromptListener()\n      removeDisplayModeListener()\n      removeAppInstalledListener()\n    }\n  },\n\n  prompt: async () => {\n    if (!window.beforeinstallpromptEvent) {\n      console.warn(`cannot prompt add to home screen: window.beforeinstallpromptEvent is missing`)\n      return false\n    }\n\n    window.beforeinstallpromptEvent.prompt()\n    const choiceResult = await window.beforeinstallpromptEvent.userChoice\n    if (choiceResult.outcome === \"accepted\") {\n      return true\n    }\n    return false\n  },\n}\n\nconst listenBeforeInstallPrompt = (callback) => listenEvent(window, \"beforeinstallprompt\", callback)\n",
    "/* eslint-disable no-eq-null, eqeqeq */\nexport default function arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length\n  var arr2 = new Array(len)\n  for (var i = 0; i < len; i++) arr2[i] = arr[i]\n  return arr2\n}\n",
    "import arrayWithoutHoles from \"../arrayWithoutHoles/arrayWithoutHoles.js\"\nimport iterableToArray from \"../iterableToArray/iterableToArray.js\"\nimport unsupportedIterableToArray from \"../unsupportedIterableToArray/unsupportedIterableToArray.js\"\nimport nonIterableSpread from \"../nonIterableSpread/nonIterableSpread.js\"\n\nexport default (arr) =>\n  arrayWithoutHoles(arr) ||\n  iterableToArray(arr) ||\n  unsupportedIterableToArray(arr) ||\n  nonIterableSpread()\n",
    "import arrayLikeToArray from \"../arrayLikeToArray/arrayLikeToArray.js\"\n\n// eslint-disable-next-line consistent-return\nexport default (arr) => {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr)\n}\n",
    "export default function _iterableToArray(iter) {\n  if (\n    (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null) ||\n    iter[\"@@iterator\"] != null\n  )\n    return Array.from(iter)\n}\n",
    "/* eslint-disable consistent-return */\nimport arrayLikeToArray from \"../arrayLikeToArray/arrayLikeToArray.js\"\n\nexport default function unsupportedIterableToArray(o, minLen) {\n  if (!o) return\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen)\n  var n = Object.prototype.toString.call(o).slice(8, -1)\n  if (n === \"Object\" && o.constructor) n = o.constructor.name\n  if (n === \"Map\" || n === \"Set\") return Array.from(o)\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return arrayLikeToArray(o, minLen)\n}\n",
    "export default () => {\n  throw new TypeError(\n    \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\",\n  )\n}\n",
    "// do not forget error handling: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/onerror\n\nimport { createSignal } from \"./internal/createSignal.js\"\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { sendMessageUsingChannel } from \"./internal/sendMessageUsingChannel.js\"\n\nconst serviceWorkerAPI = window.navigator.serviceWorker\nlet logEnabled = false\nconst log = (...args) => {\n  if (logEnabled) {\n    console.log(...args)\n  }\n}\n\nexport const enableServiceWorkerLogs = () => {\n  logEnabled = true\n}\n\nexport const canUseServiceWorker =\n  Boolean(serviceWorkerAPI) && document.location.protocol === \"https:\"\n\n// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\nlet registrationPromise = null\nlet serviceWorker = null\nconst serviceWorkerSetter = (worker) => {\n  serviceWorker = worker\n}\n\nlet serviceWorkerUpdating = null\nconst serviceWorkerUpdatingChangeSignal = createSignal()\nconst serviceWorkerUpdatingSetter = (worker) => {\n  if (serviceWorkerUpdating && serviceWorkerUpdating === worker) {\n    // we already know about this worker, no need to listen state changes.\n    // it happens for manual updates where we bot detect it\n    // from registration.update() return value\n    // and \"updatefound\" event\n    log(\"we already know this worker is updating\")\n    return\n  }\n  if (worker) {\n    log(`found a worker updating (worker state is: ${worker.state})`)\n  } else {\n    log(`worker update is done`)\n  }\n  serviceWorkerUpdating = worker\n  serviceWorkerUpdatingChangeSignal.emit()\n}\n\nexport const serviceWorkerIsAvailable = () => Boolean(registrationPromise)\n\nexport const registerServiceWorker = (url, { scope } = {}) => {\n  if (!canUseServiceWorker) {\n    return () => {}\n  }\n\n  let unregistered = false\n  let unregister = () => {}\n  let removeUpdateFoundListener = () => {}\n\n  registrationPromise = serviceWorkerAPI.register(url, { scope })\n  ;(async () => {\n    const registration = await registrationPromise\n    unregister = () => {\n      registration.unregister()\n    }\n\n    if (unregistered) {\n      unregister()\n      return\n    }\n\n    const { installing, waiting, active } = registration\n    serviceWorkerSetter(installing || waiting || active)\n    removeUpdateFoundListener = listenEvent(registration, \"updatefound\", () => {\n      log(\"browser notifies use an worker is installing\")\n      if (registration.installing === installing) {\n        log(`it's not an worker update, it's first time worker registers`)\n        return\n      }\n      serviceWorkerUpdatingSetter(registration.installing)\n    })\n  })()\n\n  return () => {\n    unregistered = true\n    removeUpdateFoundListener()\n    unregister()\n  }\n}\n\n// export const getServiceWorkerState = () => {\n//   if (serviceWorker) {\n//     return serviceWorker.state\n//   }\n//   return null\n// }\n\n// export const listenServiceWorkerState = (callback) => {\n//   let removeStateChangeListener = () => {}\n//   const removeWorkerChangeListener = serviceWorkerChangeSignal.listen(() => {\n//     callback()\n//     removeStateChangeListener = listenEvent(serviceWorker, \"statechange\", callback)\n//   })\n//   return () => {\n//     removeWorkerChangeListener()\n//     removeStateChangeListener()\n//   }\n// }\n\n// For now this function will try to communicate with the old service worker\n// even if new worker is activating or activated.\n// It might not work because, from what I understood, the old worker gets killed\n// by the navigator as soon as the new worker starts to activate.\n// Maybe it should communicate with the new worker as soon as we know\n// updating worker is activating or activated.\n// -> yes\nexport const sendMessageToServiceWorker = (message) => {\n  if (!serviceWorker) {\n    console.warn(`no service worker to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorker, message)\n}\n\nexport const getServiceWorkerUpdate = () => {\n  return serviceWorkerUpdating\n    ? {\n        shouldBecomeNavigatorController: Boolean(serviceWorkerAPI.controller),\n        navigatorWillReload: autoReloadEnabled,\n      }\n    : null\n}\n\nexport const listenServiceWorkerUpdate = (callback) => {\n  return serviceWorkerUpdatingChangeSignal.listen(callback)\n}\n\nexport const checkServiceWorkerUpdate = async () => {\n  if (!registrationPromise) {\n    console.warn(`registerServiceWorker must be called before checkServiceWorkerUpdate can be used`)\n    return false\n  }\n\n  const registration = await registrationPromise\n  // await for the registration promise above can take some time\n  // especially when the service worker is installing for the first time\n  // because it is fetching a lot of urls to put into cache.\n  // In that scenario we might want to display something different ?\n  // Without this UI seems to take ages to check for an update\n  const updateRegistration = await registration.update()\n\n  const { installing } = updateRegistration\n  if (installing) {\n    log(\"installing worker found after calling update()\")\n    serviceWorkerUpdatingSetter(installing)\n    return true\n  }\n\n  const { waiting } = updateRegistration\n  if (waiting) {\n    log(\"waiting worker found after calling update()\")\n    serviceWorkerUpdatingSetter(waiting)\n    return true\n  }\n\n  log(\"no worker found after calling update()\")\n  return false\n}\n\nexport const sendMessageToServiceWorkerUpdate = (message) => {\n  if (!serviceWorkerUpdating) {\n    console.warn(`no service worker updating to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorkerUpdating, message)\n}\n\nexport const activateServiceWorkerUpdate = async (params) => {\n  if (!serviceWorkerUpdating) {\n    throw new Error(\"no service worker update to activate\")\n  }\n  return sendSkipWaitingToWorker(serviceWorkerUpdating, params)\n}\n\nconst sendSkipWaitingToWorker = async (\n  worker,\n  { onActivating = () => {}, onActivated = () => {}, onBecomesNavigatorController = () => {} } = {},\n) => {\n  const { state } = worker\n  const waitUntilActivated = () => {\n    return new Promise((resolve) => {\n      const removeStateChangeListener = listenEvent(worker, \"statechange\", () => {\n        if (worker.state === \"activating\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivating()\n        }\n        if (worker.state === \"activated\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivated()\n          removeStateChangeListener()\n          resolve()\n        }\n      })\n    })\n  }\n\n  // worker must be waiting (meaning state must be \"installed\")\n  // to be able to call skipWaiting on it.\n  // If it's installing it's an error.\n  // If it's activating, we'll just skip the skipWaiting call\n  // If it's activated, we'll just return early\n  if (state === \"installed\" || state === \"activating\") {\n    if (state === \"installed\") {\n      sendMessageToServiceWorkerUpdate({ action: \"skipWaiting\" })\n    }\n    if (state === \"activating\") {\n      serviceWorkerSetter(serviceWorkerUpdating)\n    }\n    await waitUntilActivated()\n\n    if (serviceWorkerAPI.controller) {\n      const removeControllerChangeListener = listenEvent(\n        serviceWorkerAPI,\n        \"controllerchange\",\n        () => {\n          removeControllerChangeListener()\n          onBecomesNavigatorController()\n          serviceWorkerUpdatingSetter(null)\n          if (autoReloadEnabled) reload()\n        },\n      )\n    } else {\n      serviceWorkerUpdatingSetter(null)\n      if (autoReloadEnabled) reload()\n    }\n    return\n  }\n\n  serviceWorkerSetter(serviceWorkerUpdating)\n  onBecomesNavigatorController()\n  serviceWorkerUpdatingSetter(null)\n  if (autoReloadEnabled) reload()\n}\n\nlet autoReloadEnabled = true\nlet disableAutoReload = () => {}\nexport const autoReloadAfterUpdateIsEnabled = () => autoReloadEnabled\nexport const disableAutoReloadAfterUpdate = () => disableAutoReload()\n\nlet refreshing = false\nconst reload = () => {\n  if (refreshing) {\n    return\n  }\n  refreshing = true\n  window.location.reload()\n}\n\nif (canUseServiceWorker) {\n  const removeControllerChangeListener = listenEvent(serviceWorkerAPI, \"controllerchange\", reload)\n\n  disableAutoReload = () => {\n    autoReloadEnabled = false\n    removeControllerChangeListener()\n  }\n}\n\n// const navigatorIsControlledByAServiceWorker = () => {\n//   return canUseServiceWorker ? Boolean(serviceWorkerAPI.controller) : false\n// }\n\n// const getServiceWorkerControllingNavigator = () => {\n//   return navigatorIsControlledByAServiceWorker() ? serviceWorkerAPI.controller : null\n// }\n",
    "export const createSignal = () => {\n  let listeners = []\n\n  const listen = (callback, { once = false } = {}) => {\n    if (once) {\n      const callbackOriginal = callback\n      callback = (...args) => {\n        stopListening()\n        callbackOriginal(...args)\n      }\n    }\n\n    listeners = [...listeners, callback]\n\n    let removed = false\n    const stopListening = () => {\n      if (removed) return\n      removed = true\n      const listenersWithoutCallback = []\n      let i = listeners.length\n      let searching = true\n      while (i--) {\n        const listenerCandidate = listeners[i]\n        if (searching) {\n          if (listenerCandidate === callback) {\n            searching = false\n          } else {\n            listenersWithoutCallback.push(listenerCandidate)\n          }\n        } else {\n          listenersWithoutCallback.push(listenerCandidate)\n        }\n      }\n      listeners = listenersWithoutCallback\n    }\n    return stopListening\n  }\n\n  const emit = (...args) => {\n    listeners.forEach((listener) => {\n      listener(...args)\n    })\n  }\n\n  return {\n    listen,\n    emit,\n  }\n}\n",
    "// https://felixgerschau.com/how-to-communicate-with-service-workers/\nexport const sendMessageUsingChannel = (objectWithPostMessage, message) => {\n  const { port1, port2 } = new MessageChannel()\n  return new Promise((resolve, reject) => {\n    port1.onmessage = function (event) {\n      if (event.data.status === \"rejected\") {\n        reject(event.data.value)\n      } else {\n        resolve(event.data.value)\n      }\n    }\n    objectWithPostMessage.postMessage(message, [port2])\n  })\n}\n",
    "import { addToHomescreen } from \"@jsenv/pwa\"\n\nconst buttonAddToHomescreen = document.createElement(\"button\")\nbuttonAddToHomescreen.disabled = !addToHomescreen.isAvailable()\nbuttonAddToHomescreen.innerHTML = \"Add to home screen\"\ndocument.body.appendChild(buttonAddToHomescreen)\n\nbuttonAddToHomescreen.onclick = () => {\n  addToHomescreen.prompt()\n}\naddToHomescreen.listenAvailabilityChange(() => {\n  buttonAddToHomescreen.disabled = !addToHomescreen.isAvailable()\n})\n",
    "import {\n  canUseServiceWorker,\n  getServiceWorkerUpdate,\n  listenServiceWorkerUpdate,\n  checkServiceWorkerUpdate,\n  activateServiceWorkerUpdate,\n} from \"@jsenv/pwa\"\n\nconst installServiceWorkerUpdateUI = () => {\n  const buttonCheckUpdate = document.createElement(\"button\")\n  buttonCheckUpdate.innerHTML = \"Check update\"\n  const paragraph = document.createElement(\"p\")\n  document.body.appendChild(buttonCheckUpdate)\n  document.body.appendChild(paragraph)\n\n  buttonCheckUpdate.onclick = async () => {\n    buttonCheckUpdate.disabled = true\n    paragraph.innerHTML = \"checking for update\"\n    const found = await checkServiceWorkerUpdate()\n\n    if (found) {\n      // when update is found, we already know from listenServiceWorkerUpdate\n    } else {\n      buttonCheckUpdate.disabled = false\n      paragraph.innerHTML = \"No update available\"\n    }\n  }\n\n  listenServiceWorkerUpdate(() => {\n    const available = Boolean(getServiceWorkerUpdate())\n    if (available) {\n      paragraph.innerHTML = `Update available <button>Activate update</button>`\n      paragraph.querySelector(\"button\").onclick = async () => {\n        paragraph.querySelector(\"button\").disabled = true\n        await activateServiceWorkerUpdate()\n      }\n    } else {\n      paragraph.innerHTML = \"\"\n    }\n  })\n}\n\nif (canUseServiceWorker) {\n  installServiceWorkerUpdateUI()\n}\n",
    "import { registerServiceWorker } from \"@jsenv/pwa\"\n\n// wait a bit that browser is less busy to register the service worker\nconst callLater = requestIdleCallback ? requestIdleCallback : requestAnimationFrame\ncallLater(() => {\n  registerServiceWorker(\"/service-worker.js\")\n})\n",
    "import { DEV } from \"#env\"\n\nexport const greet = () => {\n  return DEV ? \"Welcome dev\" : \"Welcome\"\n}\n",
    "import \"src/pwa/pwa.js\"\nimport { greet } from \"src/greet.js\"\n\nconst faviconUrl = new URL(\"../icons/favicon.png\", import.meta.url)\n\ndocument.querySelector(\"#app\").innerHTML = `\n\n<img src=${faviconUrl} width=\"64\" />\n\n<p>${greet()}</p>`\n\n// <div id=\"app\"> now has some content to show, hide splashscreen to let user see the app\nwindow.splashscreen.remove()\n\n/*\n\nIn a big project, being ready to display the page can take time. During that time user\nsees the splashcreen. But, because splashscreen is inlined in the HTML it must remain\nsimple and should not try to provide a fancy user experience. Otherwise the code related\nto splashscreen would grow a lot while being inlined.\n\nIn such project I would create a loading screen where I can provide the fancy\nuser experience. What would happen for a user looks like this:\n\n1. main.html loading -> user see a blank page\n2. main.html loaded -> user see splashscreen\n3. browser loads main.js -> user see splashscreen\n4. main.js loaded -> splashscreen replaced by loadingscreen\n5. main.js loads the app -> user see loadingscreen\n6. app files are loaded -> loadingscreen replaced by app ui\n\nTo make this happen, app.js should contain code that will:\n1. display a loading screen\n2. remove splashscreen (so that user sees the loading screen instead of splashscreen)\n3. starts to load files used to display the actual application ui\n4. Eventually inform user of load progression\n5. display the actual ui into the page\n6. remove loading screen (to let user see the actual ui)\n\n*/\n"
  ],
  "names": [
    "listenEvent",
    "objectWithEventEmitter",
    "event",
    "callback",
    "addEventListener",
    "removeEventListener",
    "listenAppInstalled",
    "window",
    "displayModeStandalone",
    "navigator",
    "standalone",
    "matchMedia",
    "matches",
    "media",
    "addListener",
    "removeListener",
    "appInstalledEvent",
    "f",
    "addToHomescreen",
    "isAvailable",
    "beforeinstallpromptEvent",
    "listenAvailabilityChange",
    "availablePrevious",
    "checkAvailabilityChange",
    "available",
    "removeBeforeInstallPromptListener",
    "listenBeforeInstallPrompt",
    "removeDisplayModeListener",
    "removeAppInstalledListener",
    "prompt",
    "value",
    "userChoice",
    "then",
    "choiceResult",
    "outcome",
    "direct",
    "Promise",
    "resolve",
    "console",
    "warn",
    "args",
    "i",
    "arguments",
    "length",
    "apply",
    "this",
    "e",
    "reject",
    "arrayLikeToArray",
    "arr",
    "len",
    "arr2",
    "Array",
    "isArray",
    "arrayWithoutHoles",
    "iter",
    "Symbol",
    "iterator",
    "from",
    "iterableToArray",
    "o",
    "minLen",
    "n",
    "Object",
    "prototype",
    "toString",
    "call",
    "slice",
    "constructor",
    "name",
    "test",
    "unsupportedIterableToArray",
    "TypeError",
    "nonIterableSpread",
    "_await",
    "serviceWorkerAPI",
    "serviceWorker",
    "_async",
    "_call",
    "body",
    "result",
    "listeners",
    "canUseServiceWorker",
    "Boolean",
    "document",
    "location",
    "protocol",
    "registrationPromise",
    "serviceWorkerUpdating",
    "serviceWorkerUpdatingChangeSignal",
    "listen",
    "once",
    "callbackOriginal",
    "stopListening",
    "removed",
    "listenersWithoutCallback",
    "searching",
    "listenerCandidate",
    "push",
    "emit",
    "forEach",
    "listener",
    "serviceWorkerUpdatingSetter",
    "worker",
    "state",
    "checkServiceWorkerUpdate",
    "registration",
    "update",
    "updateRegistration",
    "installing",
    "waiting",
    "sendMessageToServiceWorkerUpdate",
    "message",
    "objectWithPostMessage",
    "MessageChannel",
    "port1",
    "port2",
    "onmessage",
    "data",
    "status",
    "postMessage",
    "sendMessageUsingChannel",
    "activateServiceWorkerUpdate",
    "params",
    "Error",
    "sendSkipWaitingToWorker",
    "onActivating",
    "onActivated",
    "onBecomesNavigatorController",
    "waitUntilActivated",
    "removeStateChangeListener",
    "action",
    "controller",
    "removeControllerChangeListener",
    "reload",
    "autoReloadEnabled",
    "refreshing",
    "buttonAddToHomescreen",
    "createElement",
    "disabled",
    "innerHTML",
    "appendChild",
    "onclick",
    "requestIdleCallback",
    "requestAnimationFrame",
    "url",
    "scope",
    "unregistered",
    "unregister",
    "removeUpdateFoundListener",
    "register",
    "active",
    "registerServiceWorker",
    "buttonCheckUpdate",
    "paragraph",
    "found",
    "shouldBecomeNavigatorController",
    "navigatorWillReload",
    "querySelector",
    "installServiceWorkerUpdateUI",
    "faviconUrl",
    "URL",
    "System",
    "import",
    "splashscreen",
    "remove"
  ],
  "mappings": "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"
}