{
  "version": 3,
  "file": "main.js",
  "sources": [
    "../../node_modules/@jsenv/pwa/src/internal/listenEvent.js",
    "../../node_modules/@jsenv/pwa/src/displayModeStandalone.js",
    "../../node_modules/@jsenv/pwa/src/add-to-home-screen.js",
    "../../node_modules/@jsenv/core/helpers/babel/arrayLikeToArray/arrayLikeToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/toConsumableArray/toConsumableArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/arrayWithoutHoles/arrayWithoutHoles.js",
    "../../node_modules/@jsenv/core/helpers/babel/iterableToArray/iterableToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/unsupportedIterableToArray/unsupportedIterableToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/nonIterableSpread/nonIterableSpread.js",
    "../../node_modules/@jsenv/pwa/src/navigatorController.js",
    "../../node_modules/@jsenv/pwa/src/internal/createSignal.js",
    "../../node_modules/@jsenv/pwa/src/internal/sendMessageUsingChannel.js",
    "../../src/dom.js",
    "../../src/add-to-home-screen.js",
    "../../src/service-worker-update.js",
    "../../node_modules/@jsenv/pwa/src/listenAppInstalled.js",
    "../../src/service-worker-registration.js",
    "../../src/greet.js",
    "../../src/pwa.js"
  ],
  "sourcesContent": [
    "export const listenEvent = (objectWithEventEmitter, event, callback) => {\n  objectWithEventEmitter.addEventListener(event, callback)\n  return () => {\n    objectWithEventEmitter.removeEventListener(event, callback)\n  }\n}\n",
    "/**\n * displayModeStandalone can be used to know the current displayMode of\n * our web page is standalone (PWA)\n */\n\nexport const displayModeStandalone = {\n  get: () => window.navigator.standalone || window.matchMedia(\"(display-mode: standalone)\").matches,\n  listen: (callback) => {\n    const media = window.matchMedia(\"(display-mode: standalone)\")\n    media.addListener(callback)\n    return () => {\n      media.removeListener(callback)\n    }\n  },\n}\n",
    "/**\n  The following scenario is working:\n\n  - user click install button -> browser shows add to home screen prompt\n  - user click cancel on browser prompt\n  - user click again install button -> browser shows again add to home screen prompt\n\n  It's very easy to break this so that subsequent click does nothing.\n  Nothing means browser always returns a \"dimissed\" user choice without asking user.\n  I suspect chrome is trying to prevent malicious script to annoy user\n  by calling prompt() many times.\n\n  It's currently working because we don't hide beforeinstallpromptEvent behind a function.\n  It would be hidden behind a function if we put it into react state or\n  just by using a curried funciton like:\n\n  beforeinstallpromptEvent\n  const curriedFunction = () => {\n    beforeinstallpromptEvent.prompt()\n  }\n\n  If we do so, chrome will always dismiss subsequent click on install button. (until page is reloaded).\n  To avoid that we store the event on window.beforeinstallpromptEvent.\n*/\n\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { listenAppInstalled } from \"./listenAppInstalled.js\"\nimport { displayModeStandalone } from \"./displayModeStandalone.js\"\n\nexport const listenAddToHomescreenAvailable = (callback) => {\n  let availablePrevious\n  let appInstalledEvent = false\n  const checkAvailable = ({\n    beforeinstallpromptEventAvailableOnWindow,\n    displayModeIsStandalone,\n  }) => {\n    const available = addToHomescreenAvailableGetter({\n      beforeinstallpromptEventAvailableOnWindow,\n      displayModeIsStandalone,\n      appInstalledEvent,\n    })\n    if (available !== availablePrevious) {\n      availablePrevious = available\n      callback(available)\n    }\n  }\n\n  checkAvailable({\n    beforeinstallpromptEventAvailableOnWindow: beforeinstallpromptEventAvailableOnWindowGetter(),\n    displayModeIsStandalone: displayModeStandalone.get(),\n  })\n\n  const removeBeforeInstallPromptListener = listenBeforeInstallPrompt(\n    (beforeinstallpromptEvent) => {\n      window.beforeinstallpromptEvent = beforeinstallpromptEvent\n      checkAvailable({\n        beforeinstallpromptEventAvailableOnWindow: true,\n        displayModeIsStandalone: displayModeStandalone.get(),\n      })\n    },\n  )\n\n  const removeDisplayModeListener = displayModeStandalone.listen(() => {\n    checkAvailable({\n      beforeinstallpromptEventAvailableOnWindow: beforeinstallpromptEventAvailableOnWindowGetter(),\n      displayModeIsStandalone: displayModeStandalone.get(),\n    })\n  })\n\n  const removeAppInstalledListener = listenAppInstalled(() => {\n    // prompt \"becomes\" unavailable if user installs app\n    // it can happen if user installs app manually from browser toolbar\n    // in that case there is no point showing the install\n    // button in the ui\n    appInstalledEvent = true\n    checkAvailable({\n      beforeinstallpromptEventAvailableOnWindow: beforeinstallpromptEventAvailableOnWindowGetter(),\n      displayModeIsStandalone: displayModeStandalone.get(),\n    })\n  })\n\n  return () => {\n    removeBeforeInstallPromptListener()\n    removeDisplayModeListener()\n    removeAppInstalledListener()\n  }\n}\n\nexport const promptAddToHomescreen = async () => {\n  if (!window.beforeinstallpromptEvent) {\n    console.warn(`cannot promptAddToHomescreen: window.beforeinstallpromptEvent is missing`)\n    return false\n  }\n\n  window.beforeinstallpromptEvent.prompt()\n  const choiceResult = await window.beforeinstallpromptEvent.userChoice\n  if (choiceResult.outcome === \"accepted\") {\n    return true\n  }\n  return false\n}\n\nconst beforeinstallpromptEventAvailableOnWindowGetter = () => {\n  return Boolean(window.beforeinstallpromptEvent)\n}\n\nconst addToHomescreenAvailableGetter = ({\n  beforeinstallpromptEventAvailableOnWindow,\n  displayModeIsStandalone,\n  appInstalledEvent,\n}) => {\n  if (!beforeinstallpromptEventAvailableOnWindow) {\n    return false\n  }\n  if (displayModeIsStandalone) {\n    return false\n  }\n  if (appInstalledEvent) {\n    return false\n  }\n  return true\n}\n\nconst listenBeforeInstallPrompt = (callback) => listenEvent(window, \"beforeinstallprompt\", callback)\n",
    "/* eslint-disable no-eq-null, eqeqeq */\nexport default function arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length\n  var arr2 = new Array(len)\n  for (var i = 0; i < len; i++) arr2[i] = arr[i]\n  return arr2\n}\n",
    "import arrayWithoutHoles from \"../arrayWithoutHoles/arrayWithoutHoles.js\"\nimport iterableToArray from \"../iterableToArray/iterableToArray.js\"\nimport unsupportedIterableToArray from \"../unsupportedIterableToArray/unsupportedIterableToArray.js\"\nimport nonIterableSpread from \"../nonIterableSpread/nonIterableSpread.js\"\n\nexport default (arr) =>\n  arrayWithoutHoles(arr) ||\n  iterableToArray(arr) ||\n  unsupportedIterableToArray(arr) ||\n  nonIterableSpread()\n",
    "import arrayLikeToArray from \"../arrayLikeToArray/arrayLikeToArray.js\"\n\n// eslint-disable-next-line consistent-return\nexport default (arr) => {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr)\n}\n",
    "// eslint-disable-next-line consistent-return\nexport default (iter) => {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter)\n}\n",
    "/* eslint-disable consistent-return */\nimport arrayLikeToArray from \"../arrayLikeToArray/arrayLikeToArray.js\"\n\nexport default function unsupportedIterableToArray(o, minLen) {\n  if (!o) return\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen)\n  var n = Object.prototype.toString.call(o).slice(8, -1)\n  if (n === \"Object\" && o.constructor) n = o.constructor.name\n  if (n === \"Map\" || n === \"Set\") return Array.from(o)\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return arrayLikeToArray(o, minLen)\n}\n",
    "export default () => {\n  throw new TypeError(\n    \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\",\n  )\n}\n",
    "// do not forget error handling: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/onerror\n\nimport { createSignal } from \"./internal/createSignal.js\"\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { sendMessageUsingChannel } from \"./internal/sendMessageUsingChannel.js\"\n\nconst serviceWorkerAPI = window.navigator.serviceWorker\n\nexport const canUseServiceWorker =\n  Boolean(serviceWorkerAPI) && document.location.protocol === \"https:\"\n\n// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\nlet registrationPromise = null\nlet serviceWorker = null\nconst serviceWorkerSetter = (worker) => {\n  serviceWorker = worker\n}\n\nlet serviceWorkerUpdating = null\nconst serviceWorkerUpdatingChangeSignal = createSignal()\nconst serviceWorkerUpdatingSetter = (worker) => {\n  if (serviceWorkerUpdating && serviceWorkerUpdating === worker) {\n    // we already know about this worker, no need to listen state changes.\n    // it happens for manual updates where we bot detect it\n    // from registration.update() return value\n    // and \"updatefound\" event\n    console.log(\"we already know this worker is updating\")\n    return\n  }\n  if (worker) {\n    console.log(`found a worker updating (worker state is: ${worker.state})`)\n  } else {\n    console.log(`worker update is done`)\n  }\n  serviceWorkerUpdating = worker\n  serviceWorkerUpdatingChangeSignal.emit()\n}\n\nexport const serviceWorkerIsAvailable = () => Boolean(registrationPromise)\n\nexport const registerServiceWorker = (url, { scope } = {}) => {\n  if (!canUseServiceWorker) {\n    return () => {}\n  }\n\n  let unregistered = false\n  let unregister = () => {}\n  let removeUpdateFoundListener = () => {}\n\n  registrationPromise = serviceWorkerAPI.register(url, { scope })\n  ;(async () => {\n    const registration = await registrationPromise\n    unregister = () => {\n      registration.unregister()\n    }\n\n    if (unregistered) {\n      unregister()\n      return\n    }\n\n    const { installing, waiting, active } = registration\n    serviceWorkerSetter(installing || waiting || active)\n    removeUpdateFoundListener = listenEvent(registration, \"updatefound\", () => {\n      console.log(\"browser notifies use an worker is installing\")\n      if (registration.installing === installing) {\n        console.log(`it's not an worker update, it's first time worker registers`)\n        return\n      }\n      serviceWorkerUpdatingSetter(registration.installing)\n    })\n  })()\n\n  return () => {\n    unregistered = true\n    removeUpdateFoundListener()\n    unregister()\n  }\n}\n\n// export const getServiceWorkerState = () => {\n//   if (serviceWorker) {\n//     return serviceWorker.state\n//   }\n//   return null\n// }\n\n// export const listenServiceWorkerState = (callback) => {\n//   let removeStateChangeListener = () => {}\n//   const removeWorkerChangeListener = serviceWorkerChangeSignal.listen(() => {\n//     callback()\n//     removeStateChangeListener = listenEvent(serviceWorker, \"statechange\", callback)\n//   })\n//   return () => {\n//     removeWorkerChangeListener()\n//     removeStateChangeListener()\n//   }\n// }\n\n// For now this function will try to communicate with the old service worker\n// even if new worker is activating or activated.\n// It might not work because, from what I understood, the old worker gets killed\n// by the navigator as soon as the new worker starts to activate.\n// Maybe it should communicate with the new worker as soon as we know\n// updating worker is activating or activated.\n// -> yes\nexport const sendMessageToServiceWorker = (message) => {\n  if (!serviceWorker) {\n    console.warn(`no service worker to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorker, message)\n}\n\nexport const getServiceWorkerUpdate = () => {\n  return serviceWorkerUpdating\n    ? {\n        shouldBecomeNavigatorController: Boolean(serviceWorkerAPI.controller),\n        navigatorWillReload: autoReloadEnabled,\n      }\n    : null\n}\n\nexport const listenServiceWorkerUpdate = (callback) => {\n  return serviceWorkerUpdatingChangeSignal.listen(callback)\n}\n\nexport const checkServiceWorkerUpdate = async () => {\n  if (!registrationPromise) {\n    console.warn(`registerServiceWorker must be called before checkServiceWorkerUpdate can be used`)\n    return false\n  }\n\n  const registration = await registrationPromise\n  // await for the registration promise above can take some time\n  // especially when the service worker is installing for the first time\n  // because it is fetching a lot of urls to put into cache.\n  // In that scenario we might want to display something different ?\n  // Without this UI seems to take ages to check for an update\n  const updateRegistration = await registration.update()\n\n  const { installing } = updateRegistration\n  if (installing) {\n    console.log(\"installing worker found after calling update()\")\n    serviceWorkerUpdatingSetter(installing)\n    return true\n  }\n\n  const { waiting } = updateRegistration\n  if (waiting) {\n    console.log(\"waiting worker found after calling update()\")\n    serviceWorkerUpdatingSetter(waiting)\n    return true\n  }\n\n  console.log(\"no worker found after calling update()\")\n  return false\n}\n\nexport const sendMessageToServiceWorkerUpdate = (message) => {\n  if (!serviceWorkerUpdating) {\n    console.warn(`no service worker updating to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorkerUpdating, message)\n}\n\nexport const activateServiceWorkerUpdate = async (params) => {\n  if (!serviceWorkerUpdating) {\n    throw new Error(\"no service worker update to activate\")\n  }\n  return sendSkipWaitingToWorker(serviceWorkerUpdating, params)\n}\n\nconst sendSkipWaitingToWorker = async (\n  worker,\n  { onActivating = () => {}, onActivated = () => {}, onBecomesNavigatorController = () => {} } = {},\n) => {\n  const { state } = worker\n  const waitUntilActivated = () => {\n    return new Promise((resolve) => {\n      const removeStateChangeListener = listenEvent(worker, \"statechange\", () => {\n        if (worker.state === \"activating\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivating()\n        }\n        if (worker.state === \"activated\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivated()\n          removeStateChangeListener()\n          resolve()\n        }\n      })\n    })\n  }\n\n  // worker must be waiting (meaning state must be \"installed\")\n  // to be able to call skipWaiting on it.\n  // If it's installing it's an error.\n  // If it's activating, we'll just skip the skipWaiting call\n  // If it's activated, we'll just return early\n  if (state === \"installed\" || state === \"activating\") {\n    if (state === \"installed\") {\n      sendMessageToServiceWorkerUpdate({ action: \"skipWaiting\" })\n    }\n    if (state === \"activating\") {\n      serviceWorkerSetter(serviceWorkerUpdating)\n    }\n    await waitUntilActivated()\n\n    if (serviceWorkerAPI.controller) {\n      const removeControllerChangeListener = listenEvent(\n        serviceWorkerAPI,\n        \"controllerchange\",\n        () => {\n          removeControllerChangeListener()\n          onBecomesNavigatorController()\n          serviceWorkerUpdatingSetter(null)\n          if (autoReloadEnabled) reload()\n        },\n      )\n    } else {\n      serviceWorkerUpdatingSetter(null)\n      if (autoReloadEnabled) reload()\n    }\n    return\n  }\n\n  serviceWorkerSetter(serviceWorkerUpdating)\n  onBecomesNavigatorController()\n  serviceWorkerUpdatingSetter(null)\n  if (autoReloadEnabled) reload()\n}\n\nlet autoReloadEnabled = true\nlet disableAutoReload = () => {}\nexport const autoReloadAfterUpdateIsEnabled = () => autoReloadEnabled\nexport const disableAutoReloadAfterUpdate = () => disableAutoReload()\n\nlet refreshing = false\nconst reload = () => {\n  if (refreshing) {\n    return\n  }\n  refreshing = true\n  window.location.reload()\n}\n\nif (canUseServiceWorker) {\n  const removeControllerChangeListener = listenEvent(serviceWorkerAPI, \"controllerchange\", reload)\n\n  disableAutoReload = () => {\n    autoReloadEnabled = false\n    removeControllerChangeListener()\n  }\n}\n\n// const navigatorIsControlledByAServiceWorker = () => {\n//   return canUseServiceWorker ? Boolean(serviceWorkerAPI.controller) : false\n// }\n\n// const getServiceWorkerControllingNavigator = () => {\n//   return navigatorIsControlledByAServiceWorker() ? serviceWorkerAPI.controller : null\n// }\n",
    "export const createSignal = () => {\n  let listeners = []\n\n  const listen = (callback, { once = false } = {}) => {\n    if (once) {\n      const callbackOriginal = callback\n      callback = (...args) => {\n        stopListening()\n        callbackOriginal(...args)\n      }\n    }\n\n    listeners = [...listeners, callback]\n\n    let removed = false\n    const stopListening = () => {\n      if (removed) return\n      removed = true\n      const listenersWithoutCallback = []\n      let i = listeners.length\n      let searching = true\n      while (i--) {\n        const listenerCandidate = listeners[i]\n        if (searching) {\n          if (listenerCandidate === callback) {\n            searching = false\n          } else {\n            listenersWithoutCallback.push(listenerCandidate)\n          }\n        } else {\n          listenersWithoutCallback.push(listenerCandidate)\n        }\n      }\n      listeners = listenersWithoutCallback\n    }\n    return stopListening\n  }\n\n  const emit = (...args) => {\n    listeners.forEach((listener) => {\n      listener(...args)\n    })\n  }\n\n  return {\n    listen,\n    emit,\n  }\n}\n",
    "// https://felixgerschau.com/how-to-communicate-with-service-workers/\nexport const sendMessageUsingChannel = (objectWithPostMessage, message) => {\n  const { port1, port2 } = new MessageChannel()\n  return new Promise((resolve, reject) => {\n    port1.onmessage = function (event) {\n      if (event.data.status === \"rejected\") {\n        reject(event.data.value)\n      } else {\n        resolve(event.data.value)\n      }\n    }\n    objectWithPostMessage.postMessage(message, [port2])\n  })\n}\n",
    "export const createDOM = (stringContainingHTMLSource) => {\n  const domParser = new DOMParser()\n  const document = domParser.parseFromString(stringContainingHTMLSource, \"text/html\")\n  return document\n}\n",
    "import { listenAddToHomescreenAvailable, promptAddToHomescreen } from \"@jsenv/pwa\"\nimport { createDOM } from \"src/dom.js\"\n\nconst addToHomeScreenDocument = createDOM(`<button disabled>Add to home screen</button>`)\nconst buttonAddToHomescreen = addToHomeScreenDocument.querySelector(\"button\")\ndocument.body.appendChild(buttonAddToHomescreen)\n\nbuttonAddToHomescreen.onclick = () => {\n  promptAddToHomescreen()\n}\nlistenAddToHomescreenAvailable((available) => {\n  buttonAddToHomescreen.disabled = !available\n})\n",
    "import {\n  canUseServiceWorker,\n  getServiceWorkerUpdate,\n  listenServiceWorkerUpdate,\n  checkServiceWorkerUpdate,\n  activateServiceWorkerUpdate,\n} from \"@jsenv/pwa\"\nimport { createDOM } from \"src/dom.js\"\n\nif (canUseServiceWorker) {\n  const serviceWorkerUpdateDocument = createDOM(`\n<button>Check update</button>\n<p></p>\n`)\n  const buttonCheckUpdate = serviceWorkerUpdateDocument.querySelector(\"button\")\n  const paragraph = serviceWorkerUpdateDocument.querySelector(\"p\")\n  document.body.appendChild(buttonCheckUpdate)\n  document.body.appendChild(paragraph)\n\n  buttonCheckUpdate.onclick = async () => {\n    buttonCheckUpdate.disabled = true\n    paragraph.innerHTML = \"checking for update\"\n    const found = await checkServiceWorkerUpdate()\n\n    if (found) {\n      // when update is found, we already know from listenServiceWorkerUpdate\n    } else {\n      buttonCheckUpdate.disabled = false\n      paragraph.innerHTML = \"No update available\"\n    }\n  }\n\n  listenServiceWorkerUpdate(() => {\n    const available = Boolean(getServiceWorkerUpdate())\n    if (available) {\n      paragraph.innerHTML = `Update available <button>Activate update</button>`\n      paragraph.querySelector(\"button\").onclick = async () => {\n        paragraph.querySelector(\"button\").disabled = true\n        await activateServiceWorkerUpdate()\n      }\n    } else {\n      paragraph.innerHTML = \"\"\n    }\n  })\n}\n",
    "/**\n * - User can decide by himself to install the application from the browser toolbar.\n * - Or application code is allowed to prompt user to do so on a user interaction such\n * as after clicking on a button.\n * In these scenarios when user clicks install on that prompt displayed by the browser,\n * browser dispatch an \"appinstalled\" event.\n */\n\nexport const listenAppInstalled = (callback) => {\n  window.addEventListener(\"appinstalled\", callback)\n  return () => {\n    window.removeEventListener(\"appinstalled\", callback)\n  }\n}\n\n// listenAppInstalled(() => {\n//   document.querySelector(\"#install\").disabled = true\n// })\n",
    "import { registerServiceWorker } from \"@jsenv/pwa\"\n\n// wait a bit that browser is less busy to register the service worker\nrequestIdleCallback(() => {\n  registerServiceWorker(\"/service-worker.js\")\n})\n",
    "export const greet = () => {\n  return \"Hello world\"\n}\n",
    "import \"src/add-to-home-screen.js\"\nimport \"src/service-worker-registration.js\"\nimport \"src/service-worker-update.js\"\nimport { greet } from \"src/greet.js\"\n\nconst faviconUrl = new URL(\"../icons/favicon.png\", import.meta.url)\n\nwindow.splashscreen.remove()\n\ndocument.querySelector(\"#app\").innerHTML = `\n\n<img src=${faviconUrl} width=\"64\" />\n\n<p>${greet()}</p>`\n"
  ],
  "names": [
    "listenEvent",
    "objectWithEventEmitter",
    "event",
    "callback",
    "addEventListener",
    "removeEventListener",
    "displayModeStandalone",
    "window",
    "navigator",
    "standalone",
    "matchMedia",
    "matches",
    "media",
    "addListener",
    "removeListener",
    "f",
    "promptAddToHomescreen",
    "beforeinstallpromptEvent",
    "prompt",
    "value",
    "userChoice",
    "then",
    "choiceResult",
    "outcome",
    "direct",
    "Promise",
    "resolve",
    "console",
    "warn",
    "args",
    "i",
    "arguments",
    "length",
    "apply",
    "this",
    "e",
    "reject",
    "beforeinstallpromptEventAvailableOnWindowGetter",
    "Boolean",
    "addToHomescreenAvailableGetter",
    "beforeinstallpromptEventAvailableOnWindow",
    "displayModeIsStandalone",
    "appInstalledEvent",
    "listenBeforeInstallPrompt",
    "arrayLikeToArray",
    "arr",
    "len",
    "arr2",
    "Array",
    "isArray",
    "arrayWithoutHoles",
    "iter",
    "Symbol",
    "iterator",
    "Object",
    "from",
    "iterableToArray",
    "o",
    "minLen",
    "n",
    "prototype",
    "toString",
    "call",
    "slice",
    "constructor",
    "name",
    "test",
    "unsupportedIterableToArray",
    "TypeError",
    "nonIterableSpread",
    "_await",
    "serviceWorkerAPI",
    "serviceWorker",
    "body",
    "result",
    "listeners",
    "canUseServiceWorker",
    "document",
    "location",
    "protocol",
    "registrationPromise",
    "serviceWorkerUpdating",
    "serviceWorkerUpdatingChangeSignal",
    "listen",
    "once",
    "callbackOriginal",
    "stopListening",
    "removed",
    "listenersWithoutCallback",
    "searching",
    "listenerCandidate",
    "push",
    "emit",
    "forEach",
    "listener",
    "serviceWorkerUpdatingSetter",
    "worker",
    "log",
    "state",
    "checkServiceWorkerUpdate",
    "registration",
    "update",
    "updateRegistration",
    "installing",
    "waiting",
    "sendMessageToServiceWorkerUpdate",
    "message",
    "objectWithPostMessage",
    "MessageChannel",
    "port1",
    "port2",
    "onmessage",
    "data",
    "status",
    "postMessage",
    "sendMessageUsingChannel",
    "activateServiceWorkerUpdate",
    "params",
    "Error",
    "sendSkipWaitingToWorker",
    "onActivating",
    "onActivated",
    "onBecomesNavigatorController",
    "waitUntilActivated",
    "removeStateChangeListener",
    "action",
    "controller",
    "removeControllerChangeListener",
    "reload",
    "autoReloadEnabled",
    "refreshing",
    "createDOM",
    "stringContainingHTMLSource",
    "DOMParser",
    "parseFromString",
    "buttonAddToHomescreen",
    "querySelector",
    "appendChild",
    "onclick",
    "availablePrevious",
    "checkAvailable",
    "available",
    "removeBeforeInstallPromptListener",
    "removeDisplayModeListener",
    "removeAppInstalledListener",
    "listenAppInstalled",
    "listenAddToHomescreenAvailable",
    "disabled",
    "requestIdleCallback",
    "url",
    "scope",
    "unregistered",
    "unregister",
    "removeUpdateFoundListener",
    "register",
    "active",
    "registerServiceWorker",
    "serviceWorkerUpdateDocument",
    "buttonCheckUpdate",
    "paragraph",
    "innerHTML",
    "found",
    "shouldBecomeNavigatorController",
    "navigatorWillReload",
    "_call",
    "faviconUrl",
    "URL",
    "System",
    "import",
    "splashscreen",
    "remove"
  ],
  "mappings": "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"
}