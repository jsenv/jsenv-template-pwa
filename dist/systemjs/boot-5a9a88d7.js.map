{
  "version": 3,
  "file": "boot.js",
  "sources": [
    "../../src/boot/boot.js"
  ],
  "sourcesContent": [
    "/*\n * This file is inlined in the HTML file by [data-jsenv-force-inline]\n * Responsabilities:\n * - inject the dev ribbon in development mode\n * - Dynamic import of \"app_loader.js\" (fetch+parse+execute)\n *   - Catch error during the dynamic import\n *   - Display splashscreen during this dynamic import\n * - Call loadApp exported by \"app_loader.js\"\n *   - Provide an updateSplashscreenText\n *   - Hide splashscreen once app is ready to be displayed\n */\n\nimport { DEV } from \"#env\"\n\nif (DEV) {\n  const { injectDevRibbon } = await import(\"./dev_ribbon.js\")\n  injectDevRibbon()\n}\n\n// When it take more than \"BOOTING_SLOW\"ms for loadApp to resolve or call updateSplashscreenText\n// -> splashscreen displays <div id=\"booting_is_slow\"> content\nconst BOOTING_SLOW = 2500\n// When it takes less than \"SPLASHIN_DELAY\"ms for loadApp to resolve\n// -> we won't even show the splashscreen (happens on user second visit because everything is in browser cache)\nconst SPLASHIN_DELAY = 300\n// When less than \"SPLASHOUT_MIN_INTERVAL\"ms have ellapsed since splashin animation started\n// -> code ensures \"SPLASHOUT_MIN_INTERVAL\"ms ellapses before playing the splashout animation\n// This is to prevent a disturbing blink when loadApp resolves shortly after splashin animation\nconst SPLASHOUT_MIN_INTERVAL = 650\n\nconst appNode = document.querySelector(\"#app\")\nconst splashscreenNode = document.querySelector(\"#splashscreen\")\n\nconst BOOTING_START = \"booting_start\"\nconst BOOTING_IS_SLOW = \"booting_is_slow\"\nconst BOOTING_ERROR = \"booting_error\"\n\nconst boot = async () => {\n  if (DEV) {\n    performance.measure(`booting app`)\n  }\n\n  const bootStartMs = Date.now()\n\n  let splashIsVisible = false\n  const splashin = () => {\n    splashscreenNode.setAttribute(\"data-splashin\", \"\")\n    splashIsVisible = true\n  }\n\n  const splashout = async () => {\n    splashscreenNode.setAttribute(\"data-splashout\", \"\")\n    await new Promise((resolve) => {\n      setTimeout(() => {\n        splashIsVisible = false\n        resolve()\n      }, 300)\n    })\n  }\n\n  const killSplashscreen = () => {\n    // Here splashscreen is \"killed\" with display: 'none' but it could also\n    // be removed from the DOM\n    splashscreenNode.style.display = \"none\"\n    splashIsVisible = false\n    if (DEV) {\n      performance.measure(`app displayed`)\n    }\n  }\n\n  const splashInTimeout = setTimeout(splashin, SPLASHIN_DELAY)\n\n  const bootingIsSlowTimeout = setTimeout(() => {\n    setBootingState(BOOTING_IS_SLOW)\n  }, BOOTING_SLOW)\n\n  try {\n    setBootingState(BOOTING_START)\n    const { loadApp } = await import(\"../app_loader/app_loader.js\")\n    await loadApp({\n      updateSplashscreenText: (message) => {\n        clearTimeout(bootingIsSlowTimeout)\n        const splashscreenMessageNode = document.querySelector(\n          \"#splashscreen_message\",\n        )\n        splashscreenMessageNode.innerHTML = message\n      },\n    })\n\n    clearTimeout(splashInTimeout)\n    clearTimeout(bootingIsSlowTimeout)\n\n    if (!splashIsVisible) {\n      appNode.removeAttribute(\"data-booting\")\n      // app was super fast to load, splashscreen was not even displayed, cool\n      killSplashscreen()\n      return\n    }\n\n    const splashInMs = bootStartMs + SPLASHIN_DELAY\n    const msEllapsedSinceSplashIn = Date.now() - splashInMs\n\n    if (msEllapsedSinceSplashIn < SPLASHOUT_MIN_INTERVAL) {\n      const msToWaitToPreventBlink =\n        SPLASHOUT_MIN_INTERVAL - msEllapsedSinceSplashIn\n      await new Promise((resolve) => {\n        setTimeout(resolve, msToWaitToPreventBlink)\n      })\n    }\n\n    appNode.removeAttribute(\"data-booting\")\n    // Wait the end of the \"splashout\" animation before killing splashscreen entirely\n    await splashout()\n    killSplashscreen()\n  } catch (error) {\n    clearTimeout(bootingIsSlowTimeout)\n\n    setBootingState(BOOTING_ERROR, {\n      errorStack:\n        error.stack ||\n        `<No stack associated with this error> (Check devtools to get more info)`,\n    })\n    throw error\n  }\n}\n\nconst setBootingState = (nextBootingState, data = {}) => {\n  const splashscreenMessageNode = document.querySelector(\n    \"#splashscreen_message\",\n  )\n  splashscreenMessageNode.innerHTML = \"\"\n  const variantModel = document.querySelector(`#${nextBootingState}`)\n  const variantInstance = variantModel.cloneNode(true)\n\n  replaceNodeVariables(variantInstance, data)\n  splashscreenMessageNode.appendChild(variantInstance)\n}\n\nconst replaceNodeVariables = (node, data) => {\n  if (node.nodeName === \"#text\") {\n    node.textContent = node.textContent.replace(/\\${(\\w*)}/g, (_, key) => {\n      return data.hasOwnProperty(key) ? data[key] : \"\"\n    })\n    return\n  }\n\n  Array.from(node.childNodes).forEach((node) => {\n    replaceNodeVariables(node, data)\n  })\n}\n\nif (window.browserIsSupported) {\n  await boot()\n}\n"
  ],
  "names": [
    "value",
    "direct",
    "then",
    "Promise",
    "resolve",
    "f",
    "args",
    "i",
    "arguments",
    "length",
    "apply",
    "this",
    "e",
    "reject",
    "appNode",
    "document",
    "querySelector",
    "splashscreenNode",
    "boot",
    "bootStartMs",
    "Date",
    "now",
    "splashIsVisible",
    "splashout",
    "setAttribute",
    "setTimeout",
    "killSplashscreen",
    "style",
    "display",
    "splashInTimeout",
    "bootingIsSlowTimeout",
    "setBootingState",
    "body",
    "recover",
    "result",
    "module",
    "loadApp",
    "updateSplashscreenText",
    "message",
    "clearTimeout",
    "innerHTML",
    "removeAttribute",
    "splashInMs",
    "msEllapsedSinceSplashIn",
    "msToWaitToPreventBlink",
    "error",
    "errorStack",
    "stack",
    "nextBootingState",
    "data",
    "splashscreenMessageNode",
    "variantModel",
    "variantInstance",
    "cloneNode",
    "replaceNodeVariables",
    "appendChild",
    "node",
    "nodeName",
    "Array",
    "from",
    "childNodes",
    "forEach",
    "textContent",
    "replace",
    "_",
    "key",
    "hasOwnProperty",
    "window",
    "browserIsSupported"
  ],
  "mappings": "+EAgmBO,cAjgBA,WAAuBA,EAAOC,OAC/BA,SACGD,GAASA,EAAME,KAAOF,EAAME,QAAeC,QAAQC,UAbrD,WAAgBJ,EAAOE,EAAMD,UAC/BA,EACIC,EAAOA,EAAKF,GAASA,GAExBA,GAAUA,EAAME,OACpBF,EAAQG,QAAQC,QAAQJ,IAElBE,EAAOF,EAAME,KAAKA,GAAQF,GArB3B,WAAgBK,UACf,eACD,IAAIC,EAAO,GAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAChDD,EAAKC,GAAKC,UAAUD,cAGbJ,QAAQC,QAAQC,EAAEK,MAAMC,KAAML,IACpC,MAAMM,UACAT,QAAQU,OAAOD,KAzDzB,MASME,EAAUC,SAASC,cAAc,QACjCC,EAAmBF,SAASC,cAAc,iBAM1CE,sBAKEC,EAAcC,KAAKC,UAErBC,GAAkB,QAMhBC,uBACJN,EAAiBO,aAAa,iBAAkB,MAC1C,IAAIrB,SAASC,IACjBqB,YAAW,KACTH,GAAkB,EAClBlB,MACC,YAIDsB,EAAmB,KAGvBT,EAAiBU,MAAMC,QAAU,OACjCN,GAAkB,GAMdO,EAAkBJ,YAzBP,KACfR,EAAiBO,aAAa,gBAAiB,IAC/CF,GAAkB,IAvBC,KAgDfQ,EAAuBL,YAAW,KACtCM,EAvCoB,qBAbH,aA6hBd,SAAgBC,EAAMC,WAEvBC,EAASF,IACZ,MAAMpB,UACAqB,EAAQrB,UAEZsB,GAAUA,EAAOhC,KACbgC,EAAOhC,UAAK,EAAQ+B,GAErBC,sBA9eJH,EA5CkB,mBA6CQI,SAAO,0CAC3BC,IADEA,SACM,CACZC,uBAAyBC,IACvBC,aAAaT,GACmBf,SAASC,cACvC,yBAEsBwB,UAAYF,oBAIxCC,aAAaV,GACbU,aAAaT,IAERR,SACHR,EAAQ2B,gBAAgB,qBAExBf,UAIIgB,EAAavB,EA3EA,IA4EbwB,EAA0BvB,KAAKC,MAAQqB,SA6bnBxC,oBAnb1BY,EAAQ2B,gBAAgB,gBAiarB,SAAeT,EAAM9B,EAAMD,MAC7BA,SACIC,EAAOA,EAAK8B,KAAUA,YAGzBE,EAAS/B,QAAQC,QAAQ4B,YACtB9B,EAAOgC,EAAOhC,KAAKA,GAAQgC,EACjC,MAAOtB,UACDT,QAAQU,OAAOD,KAvadW,cACNG,SAibCQ,gBA5bGS,EA1EuB,WA2EnBC,EA3EmB,IA4EED,WACrB,IAAIxC,SAASC,IACjBqB,WAAWrB,EAASwC,QAwbdZ,KACCE,EAAOhC,KACbgC,EAAOhC,KAAKA,GAEbA,EAAKgC,GALN,IAAuBhC,EACzBgC,oBAhbMW,SACPN,aAAaT,GAEbC,EAlFkB,gBAkFa,CAC7Be,WACED,EAAME,mFAGJF,QAIJd,EAAkB,SAACiB,OAAkBC,yDAAO,SAC1CC,EAA0BnC,SAASC,cACvC,yBAEFkC,EAAwBV,UAAY,SAC9BW,EAAepC,SAASC,yBAAkBgC,IAC1CI,EAAkBD,EAAaE,WAAU,GAE/CC,EAAqBF,EAAiBH,GACtCC,EAAwBK,YAAYH,IAGhCE,EAAuB,CAACE,EAAMP,KACZ,UAAlBO,EAAKC,SAOTC,MAAMC,KAAKH,EAAKI,YAAYC,SAASL,IACnCF,EAAqBE,EAAMP,MAP3BO,EAAKM,YAAcN,EAAKM,YAAYC,QAAQ,cAAc,CAACC,EAAGC,IACrDhB,EAAKiB,eAAeD,GAAOhB,EAAKgB,GAAO,MAUhDE,OAAOC,0BACHlD"
}