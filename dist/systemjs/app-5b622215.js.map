{
  "version": 3,
  "sources": [
    "../../node_modules/@jsenv/pwa/src/internal/listenEvent.js",
    "../../node_modules/@jsenv/pwa/src/listenAppInstalled.js",
    "../../node_modules/@jsenv/pwa/src/add-to-home-screen.js",
    "../../node_modules/@jsenv/pwa/src/displayModeStandalone.js",
    "../../node_modules/@jsenv/pwa/src/navigatorController.js",
    "../../node_modules/@jsenv/pwa/src/internal/createSignal.js",
    "../../node_modules/@jsenv/pwa/src/internal/sendMessageUsingChannel.js",
    "../../src/app/pwa/service_worker.js",
    "../../src/app/pwa/pwa.js",
    "../../src/app/pwa/add_to_home_screen.js",
    "../../src/app/app.js",
    "../../src/app/greet.js"
  ],
  "names": [
    "listenEvent",
    "objectWithEventEmitter",
    "event",
    "callback",
    "addEventListener",
    "removeEventListener",
    "listenAppInstalled",
    "window",
    "appInstalledEvent",
    "f",
    "addToHomescreen",
    "isAvailable",
    "beforeinstallpromptEvent",
    "navigator",
    "standalone",
    "matchMedia",
    "matches",
    "listenAvailabilityChange",
    "availablePrevious",
    "checkAvailabilityChange",
    "available",
    "removeBeforeInstallPromptListener",
    "listenBeforeInstallPrompt",
    "removeDisplayModeListener",
    "media",
    "addListener",
    "removeListener",
    "displayModeStandalone",
    "removeAppInstalledListener",
    "prompt",
    "then",
    "choiceResult",
    "outcome",
    "value",
    "userChoice",
    "Promise",
    "resolve",
    "console",
    "warn",
    "args",
    "i",
    "arguments",
    "length",
    "apply",
    "this",
    "e",
    "reject",
    "_await",
    "direct",
    "serviceWorkerAPI",
    "serviceWorker",
    "_async",
    "_call",
    "body",
    "result",
    "canUseServiceWorker",
    "Boolean",
    "document",
    "location",
    "protocol",
    "registrationPromise",
    "serviceWorkerUpdating",
    "serviceWorkerUpdatingChangeSignal",
    "listeners",
    "listen",
    "r",
    "n",
    "once",
    "callbackOriginal",
    "stopListening",
    "removed",
    "listenersWithoutCallback",
    "searching",
    "listenerCandidate",
    "push",
    "emit",
    "t",
    "forEach",
    "listener",
    "serviceWorkerUpdatingSetter",
    "worker",
    "state",
    "checkServiceWorkerUpdate",
    "registration",
    "update",
    "updateRegistration",
    "installing",
    "waiting",
    "sendMessageToServiceWorkerUpdate",
    "message",
    "objectWithPostMessage",
    "MessageChannel",
    "port1",
    "port2",
    "onmessage",
    "data",
    "status",
    "postMessage",
    "activateServiceWorkerUpdate",
    "params",
    "Error",
    "sendSkipWaitingToWorker",
    "o",
    "onActivating",
    "a",
    "onActivated",
    "c",
    "onBecomesNavigatorController",
    "waitUntilActivated",
    "removeStateChangeListener",
    "action",
    "p",
    "controller",
    "removeControllerChangeListener",
    "reload",
    "refreshing",
    "M",
    "j",
    "H",
    "installServiceWorkerUpdateUI",
    "app",
    "buttonCheckUpdate",
    "createElement",
    "innerHTML",
    "paragraph",
    "appendChild",
    "onclick",
    "disabled",
    "found",
    "shouldBecomeNavigatorController",
    "navigatorWillReload",
    "autoReloadEnabled",
    "querySelector",
    "initPwa",
    "buttonAddToHomescreen",
    "requestIdleCallback",
    "requestAnimationFrame",
    "url",
    "scope",
    "unregistered",
    "unregister",
    "register",
    "active",
    "initServiceWorker",
    "System"
  ],
  "mappings": "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",
  "sourcesContent": [
    "export const listenEvent = (objectWithEventEmitter, event, callback) => {\n  objectWithEventEmitter.addEventListener(event, callback)\n  return () => {\n    objectWithEventEmitter.removeEventListener(event, callback)\n  }\n}\n",
    "/**\n * - User can decide by himself to install the application from the browser toolbar.\n * - Or application code is allowed to prompt user to do so on a user interaction such\n * as after clicking on a button.\n * In these scenarios when user clicks install on that prompt displayed by the browser,\n * browser dispatch an \"appinstalled\" event.\n */\n\nexport const listenAppInstalled = (callback) => {\n  window.addEventListener(\"appinstalled\", callback)\n  return () => {\n    window.removeEventListener(\"appinstalled\", callback)\n  }\n}\n\n// listenAppInstalled(() => {\n//   document.querySelector(\"#install\").disabled = true\n// })\n",
    "/**\n  The following scenario is working:\n\n  - user click install button -> browser shows add to home screen prompt\n  - user click cancel on browser prompt\n  - user click again install button -> browser shows again add to home screen prompt\n\n  It's very easy to break this so that subsequent click does nothing.\n  Nothing means browser always returns a \"dimissed\" user choice without asking user.\n  I suspect chrome is trying to prevent malicious script to annoy user\n  by calling prompt() many times.\n\n  It's currently working because we don't hide beforeinstallpromptEvent behind a function.\n  It would be hidden behind a function if we put it into react state or\n  just by using a curried funciton like:\n\n  beforeinstallpromptEvent\n  const curriedFunction = () => {\n    beforeinstallpromptEvent.prompt()\n  }\n\n  If we do so, chrome will always dismiss subsequent click on install button. (until page is reloaded).\n  To avoid that we store the event on window.beforeinstallpromptEvent.\n*/\n\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { listenAppInstalled } from \"./listenAppInstalled.js\"\nimport { displayModeStandalone } from \"./displayModeStandalone.js\"\n\nlet appInstalledEvent = false\n\nlistenAppInstalled(() => {\n  // prompt \"becomes\" unavailable if user installs app\n  // it can happen if user installs app manually from browser toolbar\n  // in that case there is no point showing the install\n  // button in the ui\n  appInstalledEvent = true\n})\n\nexport const addToHomescreen = {\n  isAvailable: () => {\n    if (!window.beforeinstallpromptEvent) {\n      return false\n    }\n\n    if (displayModeStandalone.get()) {\n      return false\n    }\n\n    if (appInstalledEvent) {\n      return false\n    }\n\n    return true\n  },\n\n  listenAvailabilityChange: (callback) => {\n    let availablePrevious = addToHomescreen.isAvailable()\n\n    const checkAvailabilityChange = () => {\n      const available = addToHomescreen.isAvailable()\n      if (available !== availablePrevious) {\n        availablePrevious = available\n        callback(available)\n      }\n    }\n\n    const removeBeforeInstallPromptListener = listenBeforeInstallPrompt(\n      (beforeinstallpromptEvent) => {\n        window.beforeinstallpromptEvent = beforeinstallpromptEvent\n        checkAvailabilityChange()\n      },\n    )\n\n    const removeDisplayModeListener = displayModeStandalone.listen(() => {\n      checkAvailabilityChange()\n    })\n\n    const removeAppInstalledListener = listenAppInstalled(() => {\n      // prompt \"becomes\" unavailable if user installs app\n      // it can happen if user installs app manually from browser toolbar\n      // in that case there is no point showing the install\n      // button in the ui\n      appInstalledEvent = true\n      checkAvailabilityChange()\n    })\n\n    return () => {\n      removeBeforeInstallPromptListener()\n      removeDisplayModeListener()\n      removeAppInstalledListener()\n    }\n  },\n\n  prompt: async () => {\n    if (!window.beforeinstallpromptEvent) {\n      console.warn(`cannot prompt add to home screen: window.beforeinstallpromptEvent is missing`)\n      return false\n    }\n\n    window.beforeinstallpromptEvent.prompt()\n    const choiceResult = await window.beforeinstallpromptEvent.userChoice\n    if (choiceResult.outcome === \"accepted\") {\n      return true\n    }\n    return false\n  },\n}\n\nconst listenBeforeInstallPrompt = (callback) => listenEvent(window, \"beforeinstallprompt\", callback)\n",
    "/**\n * displayModeStandalone can be used to know the current displayMode of\n * our web page is standalone (PWA)\n */\n\nexport const displayModeStandalone = {\n  get: () => window.navigator.standalone || window.matchMedia(\"(display-mode: standalone)\").matches,\n  listen: (callback) => {\n    const media = window.matchMedia(\"(display-mode: standalone)\")\n    media.addListener(callback)\n    return () => {\n      media.removeListener(callback)\n    }\n  },\n}\n",
    "// do not forget error handling: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/onerror\n\nimport { createSignal } from \"./internal/createSignal.js\"\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { sendMessageUsingChannel } from \"./internal/sendMessageUsingChannel.js\"\n\nconst serviceWorkerAPI = window.navigator.serviceWorker\nlet logEnabled = false\nconst log = (...args) => {\n  if (logEnabled) {\n    console.log(...args)\n  }\n}\n\nexport const enableServiceWorkerLogs = () => {\n  logEnabled = true\n}\n\nexport const canUseServiceWorker =\n  Boolean(serviceWorkerAPI) && document.location.protocol === \"https:\"\n\n// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\nlet registrationPromise = null\nlet serviceWorker = null\nconst serviceWorkerSetter = (worker) => {\n  serviceWorker = worker\n}\n\nlet serviceWorkerUpdating = null\nconst serviceWorkerUpdatingChangeSignal = createSignal()\nconst serviceWorkerUpdatingSetter = (worker) => {\n  if (serviceWorkerUpdating && serviceWorkerUpdating === worker) {\n    // we already know about this worker, no need to listen state changes.\n    // it happens for manual updates where we bot detect it\n    // from registration.update() return value\n    // and \"updatefound\" event\n    log(\"we already know this worker is updating\")\n    return\n  }\n  if (worker) {\n    log(`found a worker updating (worker state is: ${worker.state})`)\n  } else {\n    log(`worker update is done`)\n  }\n  serviceWorkerUpdating = worker\n  serviceWorkerUpdatingChangeSignal.emit()\n}\n\nexport const serviceWorkerIsAvailable = () => Boolean(registrationPromise)\n\nexport const registerServiceWorker = (url, { scope } = {}) => {\n  if (!canUseServiceWorker) {\n    return () => {}\n  }\n\n  let unregistered = false\n  let unregister = () => {}\n  let removeUpdateFoundListener = () => {}\n\n  registrationPromise = serviceWorkerAPI.register(url, { scope })\n  ;(async () => {\n    const registration = await registrationPromise\n    unregister = () => {\n      registration.unregister()\n    }\n\n    if (unregistered) {\n      unregister()\n      return\n    }\n\n    const { installing, waiting, active } = registration\n    serviceWorkerSetter(installing || waiting || active)\n    removeUpdateFoundListener = listenEvent(registration, \"updatefound\", () => {\n      log(\"browser notifies use an worker is installing\")\n      if (registration.installing === installing) {\n        log(`it's not an worker update, it's first time worker registers`)\n        return\n      }\n      serviceWorkerUpdatingSetter(registration.installing)\n    })\n  })()\n\n  return () => {\n    unregistered = true\n    removeUpdateFoundListener()\n    unregister()\n  }\n}\n\n// export const getServiceWorkerState = () => {\n//   if (serviceWorker) {\n//     return serviceWorker.state\n//   }\n//   return null\n// }\n\n// export const listenServiceWorkerState = (callback) => {\n//   let removeStateChangeListener = () => {}\n//   const removeWorkerChangeListener = serviceWorkerChangeSignal.listen(() => {\n//     callback()\n//     removeStateChangeListener = listenEvent(serviceWorker, \"statechange\", callback)\n//   })\n//   return () => {\n//     removeWorkerChangeListener()\n//     removeStateChangeListener()\n//   }\n// }\n\n// For now this function will try to communicate with the old service worker\n// even if new worker is activating or activated.\n// It might not work because, from what I understood, the old worker gets killed\n// by the navigator as soon as the new worker starts to activate.\n// Maybe it should communicate with the new worker as soon as we know\n// updating worker is activating or activated.\n// -> yes\nexport const sendMessageToServiceWorker = (message) => {\n  if (!serviceWorker) {\n    console.warn(`no service worker to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorker, message)\n}\n\nexport const getServiceWorkerUpdate = () => {\n  return serviceWorkerUpdating\n    ? {\n        shouldBecomeNavigatorController: Boolean(serviceWorkerAPI.controller),\n        navigatorWillReload: autoReloadEnabled,\n      }\n    : null\n}\n\nexport const listenServiceWorkerUpdate = (callback) => {\n  return serviceWorkerUpdatingChangeSignal.listen(callback)\n}\n\nexport const checkServiceWorkerUpdate = async () => {\n  if (!registrationPromise) {\n    console.warn(`registerServiceWorker must be called before checkServiceWorkerUpdate can be used`)\n    return false\n  }\n\n  const registration = await registrationPromise\n  // await for the registration promise above can take some time\n  // especially when the service worker is installing for the first time\n  // because it is fetching a lot of urls to put into cache.\n  // In that scenario we might want to display something different ?\n  // Without this UI seems to take ages to check for an update\n  const updateRegistration = await registration.update()\n\n  const { installing } = updateRegistration\n  if (installing) {\n    log(\"installing worker found after calling update()\")\n    serviceWorkerUpdatingSetter(installing)\n    return true\n  }\n\n  const { waiting } = updateRegistration\n  if (waiting) {\n    log(\"waiting worker found after calling update()\")\n    serviceWorkerUpdatingSetter(waiting)\n    return true\n  }\n\n  log(\"no worker found after calling update()\")\n  return false\n}\n\nexport const sendMessageToServiceWorkerUpdate = (message) => {\n  if (!serviceWorkerUpdating) {\n    console.warn(`no service worker updating to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorkerUpdating, message)\n}\n\nexport const activateServiceWorkerUpdate = async (params) => {\n  if (!serviceWorkerUpdating) {\n    throw new Error(\"no service worker update to activate\")\n  }\n  return sendSkipWaitingToWorker(serviceWorkerUpdating, params)\n}\n\nconst sendSkipWaitingToWorker = async (\n  worker,\n  { onActivating = () => {}, onActivated = () => {}, onBecomesNavigatorController = () => {} } = {},\n) => {\n  const { state } = worker\n  const waitUntilActivated = () => {\n    return new Promise((resolve) => {\n      const removeStateChangeListener = listenEvent(worker, \"statechange\", () => {\n        if (worker.state === \"activating\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivating()\n        }\n        if (worker.state === \"activated\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivated()\n          removeStateChangeListener()\n          resolve()\n        }\n      })\n    })\n  }\n\n  // worker must be waiting (meaning state must be \"installed\")\n  // to be able to call skipWaiting on it.\n  // If it's installing it's an error.\n  // If it's activating, we'll just skip the skipWaiting call\n  // If it's activated, we'll just return early\n  if (state === \"installed\" || state === \"activating\") {\n    if (state === \"installed\") {\n      sendMessageToServiceWorkerUpdate({ action: \"skipWaiting\" })\n    }\n    if (state === \"activating\") {\n      serviceWorkerSetter(serviceWorkerUpdating)\n    }\n    await waitUntilActivated()\n\n    if (serviceWorkerAPI.controller) {\n      const removeControllerChangeListener = listenEvent(\n        serviceWorkerAPI,\n        \"controllerchange\",\n        () => {\n          removeControllerChangeListener()\n          onBecomesNavigatorController()\n          serviceWorkerUpdatingSetter(null)\n          if (autoReloadEnabled) reload()\n        },\n      )\n    } else {\n      serviceWorkerUpdatingSetter(null)\n      if (autoReloadEnabled) reload()\n    }\n    return\n  }\n\n  serviceWorkerSetter(serviceWorkerUpdating)\n  onBecomesNavigatorController()\n  serviceWorkerUpdatingSetter(null)\n  if (autoReloadEnabled) reload()\n}\n\nlet autoReloadEnabled = true\nlet disableAutoReload = () => {}\nexport const autoReloadAfterUpdateIsEnabled = () => autoReloadEnabled\nexport const disableAutoReloadAfterUpdate = () => disableAutoReload()\n\nlet refreshing = false\nconst reload = () => {\n  if (refreshing) {\n    return\n  }\n  refreshing = true\n  window.location.reload()\n}\n\nif (canUseServiceWorker) {\n  const removeControllerChangeListener = listenEvent(serviceWorkerAPI, \"controllerchange\", reload)\n\n  disableAutoReload = () => {\n    autoReloadEnabled = false\n    removeControllerChangeListener()\n  }\n}\n\n// const navigatorIsControlledByAServiceWorker = () => {\n//   return canUseServiceWorker ? Boolean(serviceWorkerAPI.controller) : false\n// }\n\n// const getServiceWorkerControllingNavigator = () => {\n//   return navigatorIsControlledByAServiceWorker() ? serviceWorkerAPI.controller : null\n// }\n",
    "export const createSignal = () => {\n  let listeners = []\n\n  const listen = (callback, { once = false } = {}) => {\n    if (once) {\n      const callbackOriginal = callback\n      callback = (...args) => {\n        stopListening()\n        callbackOriginal(...args)\n      }\n    }\n\n    listeners = [...listeners, callback]\n\n    let removed = false\n    const stopListening = () => {\n      if (removed) return\n      removed = true\n      const listenersWithoutCallback = []\n      let i = listeners.length\n      let searching = true\n      while (i--) {\n        const listenerCandidate = listeners[i]\n        if (searching) {\n          if (listenerCandidate === callback) {\n            searching = false\n          } else {\n            listenersWithoutCallback.push(listenerCandidate)\n          }\n        } else {\n          listenersWithoutCallback.push(listenerCandidate)\n        }\n      }\n      listeners = listenersWithoutCallback\n    }\n    return stopListening\n  }\n\n  const emit = (...args) => {\n    listeners.forEach((listener) => {\n      listener(...args)\n    })\n  }\n\n  return {\n    listen,\n    emit,\n  }\n}\n",
    "// https://felixgerschau.com/how-to-communicate-with-service-workers/\nexport const sendMessageUsingChannel = (objectWithPostMessage, message) => {\n  const { port1, port2 } = new MessageChannel()\n  return new Promise((resolve, reject) => {\n    port1.onmessage = function (event) {\n      if (event.data.status === \"rejected\") {\n        reject(event.data.value)\n      } else {\n        resolve(event.data.value)\n      }\n    }\n    objectWithPostMessage.postMessage(message, [port2])\n  })\n}\n",
    "import {\n  canUseServiceWorker,\n  registerServiceWorker,\n  getServiceWorkerUpdate,\n  listenServiceWorkerUpdate,\n  checkServiceWorkerUpdate,\n  activateServiceWorkerUpdate,\n} from \"@jsenv/pwa\"\n\nexport const initServiceWorker = (app) => {\n  if (!canUseServiceWorker) {\n    return\n  }\n\n  // wait a bit that browser is less busy to register the service worker\n  const callLater = window.requestIdleCallback || requestAnimationFrame\n  callLater(() => {\n    registerServiceWorker(\"/service_worker.js\")\n  })\n\n  installServiceWorkerUpdateUI(app)\n}\n\nconst installServiceWorkerUpdateUI = (app) => {\n  const buttonCheckUpdate = document.createElement(\"button\")\n  buttonCheckUpdate.innerHTML = \"Check update\"\n  const paragraph = document.createElement(\"p\")\n  app.appendChild(buttonCheckUpdate)\n  app.appendChild(paragraph)\n\n  buttonCheckUpdate.onclick = async () => {\n    buttonCheckUpdate.disabled = true\n    paragraph.innerHTML = \"checking for update\"\n    const found = await checkServiceWorkerUpdate()\n\n    if (found) {\n      // when update is found, we already know from listenServiceWorkerUpdate\n    } else {\n      buttonCheckUpdate.disabled = false\n      paragraph.innerHTML = \"No update available\"\n    }\n  }\n\n  listenServiceWorkerUpdate(() => {\n    const available = Boolean(getServiceWorkerUpdate())\n    if (available) {\n      paragraph.innerHTML = `Update available <button>Activate update</button>`\n      paragraph.querySelector(\"button\").onclick = async () => {\n        paragraph.querySelector(\"button\").disabled = true\n        await activateServiceWorkerUpdate()\n      }\n    } else {\n      paragraph.innerHTML = \"\"\n    }\n  })\n}\n",
    "import { initAddToHomeScreen } from \"./add_to_home_screen.js\"\nimport { initServiceWorker } from \"./service_worker.js\"\n\nexport const initPwa = (app) => {\n  initAddToHomeScreen(app)\n  initServiceWorker(app)\n}\n",
    "import { addToHomescreen } from \"@jsenv/pwa\"\n\nexport const initAddToHomeScreen = (app) => {\n  const buttonAddToHomescreen = document.createElement(\"button\")\n  buttonAddToHomescreen.disabled = !addToHomescreen.isAvailable()\n  buttonAddToHomescreen.innerHTML = \"Add to home screen\"\n  app.appendChild(buttonAddToHomescreen)\n\n  buttonAddToHomescreen.onclick = () => {\n    addToHomescreen.prompt()\n  }\n  addToHomescreen.listenAvailabilityChange(() => {\n    buttonAddToHomescreen.disabled = !addToHomescreen.isAvailable()\n  })\n}\n",
    "/**\n * The actual app UI, very simplified of course\n */\n\nimport { initPwa } from \"root/src/app/pwa/pwa.js\"\nimport { greet } from \"root/src/app/greet.js\"\n\nconst app = document.querySelector(\"#app\")\n\nexport const render = () => {\n  app.innerHTML = `\n\n<img src=${new URL(\"../logo.png\", import.meta.url)} width=\"64\" />\n\n<p>${greet()}</p>`\n\n  initPwa(app)\n}\n",
    "import { DEV } from \"#env\"\n\nexport const greet = () => {\n  return DEV ? \"Welcome dev\" : \"Welcome\"\n}\n"
  ]
}