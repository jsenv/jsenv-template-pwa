self.generatedUrlsConfig={"assets/app_loader-bced8497.css":{versioned:!0},"assets/app-0f239860.css":{versioned:!0},"assets/favicon-25e95a00.png":{versioned:!0},"assets/logo-25e95a00.png":{versioned:!0},"assets/pwa-icon-574c1c76.png":{versioned:!0},"assets/pwa.webmanifest":{versioned:!1,version:"0f3bbf19"},"assets/roboto_v27_latin_regular-cc46322d.woff2":{versioned:!0},"app_loadapp_loader-dfcf6452.js":{versioned:!0},"app-5b622215.js":{versioned:!0},"main.prod.html":{versioned:!1,version:"1a79c450"},"prod-1db1097b.importmap":{versioned:!0},"sboboot-062dd726.js":{versioned:!0}},self.config={},self.config.cachePrefix="jsenv",self.generatedUrlsConfig=self.generatedUrlsConfig||{},self.config.manualUrlsConfig={"/":{}},self.config.shouldHandleRequest=(e,{requestWasCachedOnInstall:n})=>("GET"===e.method||"HEAD"===e.method)&&n,self.config.shouldCleanOnActivate=(e,n,{requestWasCachedOnInstall:o})=>!o,self.config.logLevel="warn",self.config.logsBackgroundColor="#ffdc00",self.config.navigationPreloadEnabled=!1,self.config.actions={ping:()=>"pong"},self.config.cachePrefix="pwa-template";const assertContextLooksGood=()=>{const{generatedUrlsConfig:e}=self;if(void 0===e)self.generatedUrlsConfig={};else if("object"!=typeof e)throw new TypeError(`self.generatedUrlsConfig should be an object, got ${e}`);if(void 0===typeof config)throw new Error("config is not in scope, be sure to import sw.preconfig.js before sw.jsenv.js");const{manualUrlsConfig:n}=config;if("object"!=typeof n)throw new TypeError(`config.manualUrlsConfig should be an array, got ${n}`);const{cachePrefix:o}=config;if("string"!=typeof o)throw new TypeError(`config.cachePrefix should be a string, got ${o}`);if(0===o.length)throw new TypeError("config.cachePrefix must not be empty");const{shouldCleanOnActivate:t}=config;if("function"!=typeof t)throw new TypeError(`config.shouldCleanOnActivate should be a function, got ${t}`);const{shouldHandleRequest:r}=config;if("function"!=typeof r)throw new TypeError(`config.shouldHandleRequest should be a function, got ${r}`);const{logLevel:a}=config;if("string"!=typeof a)throw new TypeError(`config.logLevel should be a boolean, got ${a}`);const{logsBackgroundColor:s}=config;if("string"!=typeof s)throw new TypeError(`config.logsBackgroundColor should be a string, got ${s}`);const{navigationPreloadEnabled:l}=config;if("boolean"!=typeof l)throw new TypeError(`config.navigationPreloadEnabled should be a boolean, got ${l}`)},getUtil=()=>{const e={};e.createLogger=({logLevel:e,logsBackgroundColor:n})=>{const o=e=>(...o)=>console[e](...((...e)=>["%csw",`background: ${n}; color: black; padding: 1px 3px; margin: 0 1px`,...e])(...o)),t=o("debug"),r=o("info"),a=o("warn"),s=o("error"),l=()=>{};if("debug"===e)return{debug:t,info:r,warn:a,error:s};if("info"===e)return{debug:l,info:r,warn:a,error:s};if("warn"===e)return{debug:l,info:l,warn:a,error:s};if("error"===e)return{debug:l,info:l,warn:l,error:s};if("off"===e)return{debug:l,info:l,warn:l,error:l};throw new Error(`unknown logLevel, got ${e}`)},e.resolveUrl=e=>String(new URL(e,self.location));{e.responseUsesLongTermCaching=e=>{const o=e.headers.get("cache-control"),t=n(o);return t&&t>0};const n=e=>{if(!e||0===e.length)return null;const n=e.match(/([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:"([^"]*)"|([^ \t",;]*)))?/g)||[],t={};return Array.from(n).forEach((e=>{const n=e.split("=",2),[o]=n;let r=null;n.length>1&&(r=n[1].trim()),t[o.toLowerCase()]=r})),o(t["max-age"])},o=e=>{if(!e)return null;const n=Number.parseInt(e,10);return!Number.isFinite(n)||n<0?null:n}}{e.getCacheName=({cachePrefix:e})=>`${e}${l()}`;const n=36,o=4,t=Math.pow(n,o),r=(e,n)=>{var o=`000000000${e}`;return o.substr(o.length-n)},a=(()=>{const{crypto:e}=self;if(e){const n=Math.pow(2,32)-1;return()=>Math.abs(e.getRandomValues(new Uint32Array(1))[0]/n)}return Math.random})(),s=()=>r((a()*t<<0).toString(n),o),l=()=>`${(new Date).getTime().toString(n)}${`${s()}${s()}`}`}{e.readUrlConfig=()=>{const o={...self.generatedUrlsConfig,...config.manualUrlsConfig},t=[],r=[],a={};return n(o,((n,o)=>{o||(o={cache:!1}),!0===o&&(o={cache:!0});const{cache:s=!0,versioned:l=!1,alias:c}=o;s&&(t.push(n),l||r.push(n)),c&&(a[n]=e.resolveUrl(c))})),{urlsToCacheOnInstall:t,urlsToReloadOnInstall:r,urlMapping:a}};const n=(n,o)=>{const t=[];Object.keys(n).forEach((r=>{const a=e.resolveUrl(r);t.includes(a)||(t.push(a),o(a,n[r]))}))}}return e.redirectRequest=async(e,n)=>{const{mode:o}=e;if("navigate"!==o)return new Request(n,e);const t=e.clone(),{body:r,credentials:a,headers:s,integrity:l,referrer:c,referrerPolicy:i}=t,g=r?Promise.resolve(r):t.blob(),f=await g;return new Request(n,{body:f,credentials:a,headers:s,integrity:l,referrer:c,referrerPolicy:i,mode:"same-origin",redirect:"manual"})},e};assertContextLooksGood();const util=getUtil(),cacheName=util.getCacheName(config),logger=util.createLogger(config),{urlsToCacheOnInstall:urlsToCacheOnInstall,urlsToReloadOnInstall:urlsToReloadOnInstall,urlMapping:urlMapping}=util.readUrlConfig(config);logger.info(`cache key: ${cacheName}`);const install=async()=>{logger.info("install start");try{const e=urlsToCacheOnInstall.length;let n=0;await Promise.all(urlsToCacheOnInstall.map((async e=>{try{const o=urlsToReloadOnInstall.includes(e),t=new Request(e,{...o?{cache:"reload"}:{}});await fetchAndCache(t,{oncache:()=>{n+=1}})}catch(n){logger.warn(`cannot put ${e} in cache due to error while fetching: ${n.stack}`)}}))),n===e?logger.info(`install done (${e} urls added in cache)`):logger.info(`install done (${n}/${e} urls added in cache)`)}catch(e){logger.error(`install error: ${e.stack}`)}};self.addEventListener("install",(e=>{e.waitUntil(install())}));const handleRequest=async(e,n)=>{logger.debug(`received fetch event for ${e.url}`);try{const o=await self.caches.match(e);if(o)return logger.debug(`respond with response from cache for ${e.url}`),o;const t=await n.preloadResponse;if(t)return logger.debug(`respond with preloaded response for ${e.url}`),t}catch(n){return logger.warn(`error while trying to use cache for ${e.url}`,n.stack),fetch(e)}return logger.debug(`no cache for ${e.url}, fetching it`),fetchAndCache(e)},remapRequest=e=>{if(Object.prototype.hasOwnProperty.call(urlMapping,e.url)){const n=urlMapping[e.url];return logger.debug(`redirect request from ${e.url} to ${n}`),util.redirectRequest(e,n)}return e};self.addEventListener("fetch",(e=>{const n=remapRequest(e.request);if(config.shouldHandleRequest(n,{requestWasCachedOnInstall:urlsToCacheOnInstall.includes(n.url)})){const o=handleRequest(n,e);o&&e.respondWith(o)}}));const activate=async()=>{logger.info("activate start"),await Promise.all([enableNavigationPreloadIfPossible(),deleteOtherUrls(),deleteOtherCaches()]),logger.info("activate done")},enableNavigationPreloadIfPossible=async()=>{config.navigationPreloadEnabled&&self.registration.navigationPreload&&await self.registration.navigationPreload.enable()},deleteOtherUrls=async()=>{const e=await self.caches.open(cacheName),n=await e.keys();await Promise.all(n.map((async n=>{const o=await e.match(n);config.shouldCleanOnActivate(o,n,{requestWasCachedOnInstall:urlsToCacheOnInstall.includes(n.url)})&&(logger.info(`delete ${n.url}`),await e.delete(n))})))},deleteOtherCaches=async()=>{const e=await self.caches.keys();await Promise.all(e.map((async e=>{e!==cacheName&&e.startsWith(config.cachePrefix)&&(logger.info(`delete cache ${e}`),await self.caches.delete(e))})))};self.addEventListener("activate",(e=>{const n=activate();n&&e.waitUntil(n)}));const actions={skipWaiting:()=>{self.skipWaiting()},refreshCacheKey:async e=>{e=util.resolveUrl(e);return(await fetchAndCache(new Request(e,{cache:"reload"}))).status},addCacheKey:async e=>{e=util.resolveUrl(e);return(await fetchAndCache(e)).status},removeCacheKey:async e=>{e=util.resolveUrl(e);const n=await self.caches.open(cacheName);return await n.delete(e)},...config.actions};self.addEventListener("message",(async e=>{const{data:n}=e;if("object"!=typeof n)return;const{action:o}=n,t=actions[o];if(!t)return;const{payload:r}=n;let a,s;try{const e=await t(r,{cacheName:cacheName});a="resolved",s=e}catch(e){a="rejected",s=e}e.ports[0].postMessage({status:a,value:s})}));const fetchAndCache=async(e,{oncache:n}={})=>{const[o,t]=await Promise.all([fetchUsingNetwork(e),getCache()]);if(200===o.status){logger.debug(`fresh response found for ${e.url}, put it in cache and respond with it`);const r=await responseToResponseForCache(o),a=t.put(e,r);return n&&(await a,n()),o}return logger.warn(`cannot put ${e.url} in cache due to response status (${o.status})`),o},responseToResponseForCache=async e=>{const n=e.clone();if(!e.redirected)return n;const o="body"in n?Promise.resolve(n.body):n.blob(),t=await o;return new Response(t,{headers:n.headers,status:n.status,statusText:n.statusText})},fetchUsingNetwork=async e=>{const n=new AbortController,{signal:o}=n;try{return await fetch(e,{signal:o})}catch(e){throw n.abort(),e}},getCache=async()=>await self.caches.open(cacheName);
//# sourceMappingURL=service_worker.js.map