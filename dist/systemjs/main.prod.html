<!DOCTYPE html><html lang="en"><head>
    <title>PWA Example</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Progressive Web Application template using jsenv">
    <meta name="theme-color" content="#d3d3d3">
    <link rel="icon" href="assets/favicon-25e95a00.png">
    <link rel="manifest" href="assets/pwa.webmanifest">
    <link rel="apple-touch-icon" href="assets/logo-25e95a00.png">
    <!--
      boot.css contains styles for the following use cases:
      - JavaScript is disabled
      - Browser is not supported
      - App is "booting" (detailed later in this file)
      boot.css is part of the ressources inlined in this HTML during build
      by [data-jsenv-force-inline] attribute
    --->
    <style>/*
 * This file is inlined in the HTML file by [data-jsenv-force-inline]
 * Responsabilities:
 * - Set styles for js disabled (<noscript>)
 * - Set styles for "browser not supported" message
 * - Set styles for initial html while the app is booting (splashscreen)
 * Not in the scope of this file:
 * - Styles while the app is loading, it's the role of app_loader.css
 */

noscript {
  display: block;
  text-align: center;
  width: 80%;
  max-width: 640px;
  margin: auto;
}

#browser_not_supported {
  display: block;
  text-align: center;
  width: 80%;
  max-width: 640px;
  margin: auto;
}

#app[data-booting] {
  width: 100%;
  height: 100%;
  visibility: hidden; /* Hides app while its booting */
  overflow: hidden; /* While app is booting layout might be broken -> prevent scrollbar */
}

#splashscreen {
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  background-color: #030713;
  color: #a9a8a8;
  display: flex;
  flex-direction: column;
  align-items: center;
  opacity: 0;
}
#splashscreen[data-splashin] {
  animation-name: splashin;
  animation-duration: 0.4s;
  animation-fill-mode: forwards;
}
@keyframes splashin {
  from {
    opacity: 0;
    /* transform: scale(0); */
  }

  to {
    opacity: 1;
    /* transform: scale(1); */
  }
}
#splashscreen_logo {
  margin: 32px;
}
#splashscreen_message {
  display: flex;
  justify-content: center;
  flex: 1;
  width: 80%;
  max-width: 640px;
  margin: 32px;
}
#booting_error {
  display: block;
  text-align: center;
  width: 100%;
}
#booting_error p {
  display: inline-block;
  color: #ba3939;
  background: #ffe0e0;
  border: 1px solid #a33a3a;
  padding: 16px 48px;
}
#booting_error details {
  display: inline-block;
  max-width: 100%;
}
#booting_error details summary {
  text-align: center;
}
#booting_error details pre {
  text-align: left;
  overflow: auto;
}
#splashscreen[data-splashout] {
  animation-duration: 0.3s;
  animation-name: splashout;
  animation-fill-mode: forwards;
}
@keyframes splashout {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
    display: none;
  }
}

/*# sourceMappingURL=assets/boot.css-ac3ce97e.map */</style>
    <!--
      This HTML uses "dev.importmap" to control how js import are resolved.
      It is used to have code specific to dev or prod.
      See https://github.com/jsenv/jsenv-template-pwa/blob/main/docs/production_mode/readme.md#production-mode
    -->
    <script id="jsenv_inject_systemjs">/*
* SJS 6.11.0
* Minimal SystemJS Build
*/
(function () {

  function errMsg(errCode, msg) {
    return (msg || "") + " (SystemJS https://git.io/JvFET#" + errCode + ")";
  }

  var hasSymbol = typeof Symbol !== 'undefined';
  var hasSelf = typeof self !== 'undefined';
  var hasDocument = typeof document !== 'undefined';

  var envGlobal = hasSelf ? self : global;

  var baseUrl;

  if (hasDocument) {
    var baseEl = document.querySelector('base[href]');
    if (baseEl)
      baseUrl = baseEl.href;
  }

  if (!baseUrl && typeof location !== 'undefined') {
    baseUrl = location.href.split('#')[0].split('?')[0];
    var lastSepIndex = baseUrl.lastIndexOf('/');
    if (lastSepIndex !== -1)
      baseUrl = baseUrl.slice(0, lastSepIndex + 1);
  }

  var backslashRegEx = /\\/g;
  function resolveIfNotPlainOrUrl (relUrl, parentUrl) {
    if (relUrl.indexOf('\\') !== -1)
      relUrl = relUrl.replace(backslashRegEx, '/');
    // protocol-relative
    if (relUrl[0] === '/' && relUrl[1] === '/') {
      return parentUrl.slice(0, parentUrl.indexOf(':') + 1) + relUrl;
    }
    // relative-url
    else if (relUrl[0] === '.' && (relUrl[1] === '/' || relUrl[1] === '.' && (relUrl[2] === '/' || relUrl.length === 2 && (relUrl += '/')) ||
        relUrl.length === 1  && (relUrl += '/')) ||
        relUrl[0] === '/') {
      var parentProtocol = parentUrl.slice(0, parentUrl.indexOf(':') + 1);
      // Disabled, but these cases will give inconsistent results for deep backtracking
      //if (parentUrl[parentProtocol.length] !== '/')
      //  throw Error('Cannot resolve');
      // read pathname from parent URL
      // pathname taken to be part after leading "/"
      var pathname;
      if (parentUrl[parentProtocol.length + 1] === '/') {
        // resolving to a :// so we need to read out the auth and host
        if (parentProtocol !== 'file:') {
          pathname = parentUrl.slice(parentProtocol.length + 2);
          pathname = pathname.slice(pathname.indexOf('/') + 1);
        }
        else {
          pathname = parentUrl.slice(8);
        }
      }
      else {
        // resolving to :/ so pathname is the /... part
        pathname = parentUrl.slice(parentProtocol.length + (parentUrl[parentProtocol.length] === '/'));
      }

      if (relUrl[0] === '/')
        return parentUrl.slice(0, parentUrl.length - pathname.length - 1) + relUrl;

      // join together and split for removal of .. and . segments
      // looping the string instead of anything fancy for perf reasons
      // '../../../../../z' resolved to 'x/y' is just 'z'
      var segmented = pathname.slice(0, pathname.lastIndexOf('/') + 1) + relUrl;

      var output = [];
      var segmentIndex = -1;
      for (var i = 0; i < segmented.length; i++) {
        // busy reading a segment - only terminate on '/'
        if (segmentIndex !== -1) {
          if (segmented[i] === '/') {
            output.push(segmented.slice(segmentIndex, i + 1));
            segmentIndex = -1;
          }
        }

        // new segment - check if it is relative
        else if (segmented[i] === '.') {
          // ../ segment
          if (segmented[i + 1] === '.' && (segmented[i + 2] === '/' || i + 2 === segmented.length)) {
            output.pop();
            i += 2;
          }
          // ./ segment
          else if (segmented[i + 1] === '/' || i + 1 === segmented.length) {
            i += 1;
          }
          else {
            // the start of a new segment as below
            segmentIndex = i;
          }
        }
        // it is the start of a new segment
        else {
          segmentIndex = i;
        }
      }
      // finish reading out the last segment
      if (segmentIndex !== -1)
        output.push(segmented.slice(segmentIndex));
      return parentUrl.slice(0, parentUrl.length - pathname.length) + output.join('');
    }
  }

  /*
   * Import maps implementation
   *
   * To make lookups fast we pre-resolve the entire import map
   * and then match based on backtracked hash lookups
   *
   */

  function resolveUrl (relUrl, parentUrl) {
    return resolveIfNotPlainOrUrl(relUrl, parentUrl) || (relUrl.indexOf(':') !== -1 ? relUrl : resolveIfNotPlainOrUrl('./' + relUrl, parentUrl));
  }

  function resolveAndComposePackages (packages, outPackages, baseUrl, parentMap, parentUrl) {
    for (var p in packages) {
      var resolvedLhs = resolveIfNotPlainOrUrl(p, baseUrl) || p;
      var rhs = packages[p];
      // package fallbacks not currently supported
      if (typeof rhs !== 'string')
        continue;
      var mapped = resolveImportMap(parentMap, resolveIfNotPlainOrUrl(rhs, baseUrl) || rhs, parentUrl);
      if (!mapped) {
        targetWarning('W1', p, rhs);
      }
      else
        outPackages[resolvedLhs] = mapped;
    }
  }

  function resolveAndComposeImportMap (json, baseUrl, outMap) {
    if (json.imports)
      resolveAndComposePackages(json.imports, outMap.imports, baseUrl, outMap, null);

    var u;
    for (u in json.scopes || {}) {
      var resolvedScope = resolveUrl(u, baseUrl);
      resolveAndComposePackages(json.scopes[u], outMap.scopes[resolvedScope] || (outMap.scopes[resolvedScope] = {}), baseUrl, outMap, resolvedScope);
    }

    for (u in json.depcache || {})
      outMap.depcache[resolveUrl(u, baseUrl)] = json.depcache[u];

    for (u in json.integrity || {})
      outMap.integrity[resolveUrl(u, baseUrl)] = json.integrity[u];
  }

  function getMatch (path, matchObj) {
    if (matchObj[path])
      return path;
    var sepIndex = path.length;
    do {
      var segment = path.slice(0, sepIndex + 1);
      if (segment in matchObj)
        return segment;
    } while ((sepIndex = path.lastIndexOf('/', sepIndex - 1)) !== -1)
  }

  function applyPackages (id, packages) {
    var pkgName = getMatch(id, packages);
    if (pkgName) {
      var pkg = packages[pkgName];
      if (pkg === null) return;
      if (id.length > pkgName.length && pkg[pkg.length - 1] !== '/') {
        targetWarning('W2', pkgName, pkg);
      }
      else
        return pkg + id.slice(pkgName.length);
    }
  }

  function targetWarning (code, match, target, msg) {
    console.warn(errMsg(code,  [target, match].join(', ') ));
  }

  function resolveImportMap (importMap, resolvedOrPlain, parentUrl) {
    var scopes = importMap.scopes;
    var scopeUrl = parentUrl && getMatch(parentUrl, scopes);
    while (scopeUrl) {
      var packageResolution = applyPackages(resolvedOrPlain, scopes[scopeUrl]);
      if (packageResolution)
        return packageResolution;
      scopeUrl = getMatch(scopeUrl.slice(0, scopeUrl.lastIndexOf('/')), scopes);
    }
    return applyPackages(resolvedOrPlain, importMap.imports) || resolvedOrPlain.indexOf(':') !== -1 && resolvedOrPlain;
  }

  /*
   * SystemJS Core
   *
   * Provides
   * - System.import
   * - System.register support for
   *     live bindings, function hoisting through circular references,
   *     reexports, dynamic import, import.meta.url, top-level await
   * - System.getRegister to get the registration
   * - Symbol.toStringTag support in Module objects
   * - Hookable System.createContext to customize import.meta
   * - System.onload(err, id, deps) handler for tracing / hot-reloading
   *
   * Core comes with no System.prototype.resolve or
   * System.prototype.instantiate implementations
   */

  var toStringTag = hasSymbol && Symbol.toStringTag;
  var REGISTRY = hasSymbol ? Symbol() : '@';

  function SystemJS () {
    this[REGISTRY] = {};
  }

  var systemJSPrototype = SystemJS.prototype;

  systemJSPrototype.import = function (id, parentUrl) {
    var loader = this;
    return Promise.resolve(loader.prepareImport())
    .then(function() {
      return loader.resolve(id, parentUrl);
    })
    .then(function (id) {
      var load = getOrCreateLoad(loader, id);
      return load.C || topLevelLoad(loader, load);
    });
  };

  // Hookable createContext function -> allowing eg custom import meta
  systemJSPrototype.createContext = function (parentId) {
    var loader = this;
    return {
      url: parentId,
      resolve: function (id, parentUrl) {
        return Promise.resolve(loader.resolve(id, parentUrl || parentId));
      }
    };
  };
  function loadToId (load) {
    return load.id;
  }
  function triggerOnload (loader, load, err, isErrSource) {
    loader.onload(err, load.id, load.d && load.d.map(loadToId), !!isErrSource);
    if (err)
      throw err;
  }

  var lastRegister;
  systemJSPrototype.register = function (deps, declare) {
    lastRegister = [deps, declare];
  };

  /*
   * getRegister provides the last anonymous System.register call
   */
  systemJSPrototype.getRegister = function () {
    var _lastRegister = lastRegister;
    lastRegister = undefined;
    return _lastRegister;
  };

  function getOrCreateLoad (loader, id, firstParentUrl) {
    var load = loader[REGISTRY][id];
    if (load)
      return load;

    var importerSetters = [];
    var ns = Object.create(null);
    if (toStringTag)
      Object.defineProperty(ns, toStringTag, { value: 'Module' });

    var instantiatePromise = Promise.resolve()
    .then(function () {
      return loader.instantiate(id, firstParentUrl);
    })
    .then(function (registration) {
      if (!registration)
        throw Error(errMsg(2,  id ));
      function _export (name, value) {
        // note if we have hoisted exports (including reexports)
        load.h = true;
        var changed = false;
        if (typeof name === 'string') {
          if (!(name in ns) || ns[name] !== value) {
            ns[name] = value;
            changed = true;
          }
        }
        else {
          for (var p in name) {
            var value = name[p];
            if (!(p in ns) || ns[p] !== value) {
              ns[p] = value;
              changed = true;
            }
          }

          if (name && name.__esModule) {
            ns.__esModule = name.__esModule;
          }
        }
        if (changed)
          for (var i = 0; i < importerSetters.length; i++) {
            var setter = importerSetters[i];
            if (setter) setter(ns);
          }
        return value;
      }
      var declared = registration[1](_export, registration[1].length === 2 ? {
        import: function (importId) {
          return loader.import(importId, id);
        },
        meta: loader.createContext(id)
      } : undefined);
      load.e = declared.execute || function () {};
      return [registration[0], declared.setters || []];
    }, function (err) {
      load.e = null;
      load.er = err;
      throw err;
    });

    var linkPromise = instantiatePromise
    .then(function (instantiation) {
      return Promise.all(instantiation[0].map(function (dep, i) {
        var setter = instantiation[1][i];
        return Promise.resolve(loader.resolve(dep, id))
        .then(function (depId) {
          var depLoad = getOrCreateLoad(loader, depId, id);
          // depLoad.I may be undefined for already-evaluated
          return Promise.resolve(depLoad.I)
          .then(function () {
            if (setter) {
              depLoad.i.push(setter);
              // only run early setters when there are hoisted exports of that module
              // the timing works here as pending hoisted export calls will trigger through importerSetters
              if (depLoad.h || !depLoad.I)
                setter(depLoad.n);
            }
            return depLoad;
          });
        });
      }))
      .then(function (depLoads) {
        load.d = depLoads;
      });
    });

    // Capital letter = a promise function
    return load = loader[REGISTRY][id] = {
      id: id,
      // importerSetters, the setters functions registered to this dependency
      // we retain this to add more later
      i: importerSetters,
      // module namespace object
      n: ns,

      // instantiate
      I: instantiatePromise,
      // link
      L: linkPromise,
      // whether it has hoisted exports
      h: false,

      // On instantiate completion we have populated:
      // dependency load records
      d: undefined,
      // execution function
      e: undefined,

      // On execution we have populated:
      // the execution error if any
      er: undefined,
      // in the case of TLA, the execution promise
      E: undefined,

      // On execution, L, I, E cleared

      // Promise for top-level completion
      C: undefined,

      // parent instantiator / executor
      p: undefined
    };
  }

  function instantiateAll (loader, load, parent, loaded) {
    if (!loaded[load.id]) {
      loaded[load.id] = true;
      // load.L may be undefined for already-instantiated
      return Promise.resolve(load.L)
      .then(function () {
        if (!load.p || load.p.e === null)
          load.p = parent;
        return Promise.all(load.d.map(function (dep) {
          return instantiateAll(loader, dep, parent, loaded);
        }));
      })
      .catch(function (err) {
        if (load.er)
          throw err;
        load.e = null;
        throw err;
      });
    }
  }

  function topLevelLoad (loader, load) {
    return load.C = instantiateAll(loader, load, load, {})
    .then(function () {
      return postOrderExec(loader, load, {});
    })
    .then(function () {
      return load.n;
    });
  }

  // the closest we can get to call(undefined)
  var nullContext = Object.freeze(Object.create(null));

  // returns a promise if and only if a top-level await subgraph
  // throws on sync errors
  function postOrderExec (loader, load, seen) {
    if (seen[load.id])
      return;
    seen[load.id] = true;

    if (!load.e) {
      if (load.er)
        throw load.er;
      if (load.E)
        return load.E;
      return;
    }

    // deps execute first, unless circular
    var depLoadPromises;
    load.d.forEach(function (depLoad) {
      try {
        var depLoadPromise = postOrderExec(loader, depLoad, seen);
        if (depLoadPromise)
          (depLoadPromises = depLoadPromises || []).push(depLoadPromise);
      }
      catch (err) {
        load.e = null;
        load.er = err;
        throw err;
      }
    });
    if (depLoadPromises)
      return Promise.all(depLoadPromises).then(doExec);

    return doExec();

    function doExec () {
      try {
        var execPromise = load.e.call(nullContext);
        if (execPromise) {
          execPromise = execPromise.then(function () {
            load.C = load.n;
            load.E = null; // indicates completion
            if (!true) ;
          }, function (err) {
            load.er = err;
            load.E = null;
            if (!true) ;
            throw err;
          });
          return load.E = execPromise;
        }
        // (should be a promise, but a minify optimization to leave out Promise.resolve)
        load.C = load.n;
        load.L = load.I = undefined;
      }
      catch (err) {
        load.er = err;
        throw err;
      }
      finally {
        load.e = null;
      }
    }
  }

  envGlobal.System = new SystemJS();

  /*
   * SystemJS browser attachments for script and import map processing
   */

  var importMapPromise = Promise.resolve();
  var importMap = { imports: {}, scopes: {}, depcache: {}, integrity: {} };

  // Scripts are processed immediately, on the first System.import, and on DOMReady.
  // Import map scripts are processed only once (by being marked) and in order for each phase.
  // This is to avoid using DOM mutation observers in core, although that would be an alternative.
  var processFirst = hasDocument;
  systemJSPrototype.prepareImport = function (doProcessScripts) {
    if (processFirst || doProcessScripts) {
      processScripts();
      processFirst = false;
    }
    return importMapPromise;
  };
  if (hasDocument) {
    processScripts();
    window.addEventListener('DOMContentLoaded', processScripts);
  }

  function processScripts () {
    [].forEach.call(document.querySelectorAll('script'), function (script) {
      if (script.sp) // sp marker = systemjs processed
        return;
      // TODO: deprecate systemjs-module in next major now that we have auto import
      if (script.type === 'systemjs-module') {
        script.sp = true;
        if (!script.src)
          return;
        System.import(script.src.slice(0, 7) === 'import:' ? script.src.slice(7) : resolveUrl(script.src, baseUrl)).catch(function (e) {
          // if there is a script load error, dispatch an "error" event
          // on the script tag.
          if (e.message.indexOf('https://git.io/JvFET#3') > -1) {
            var event = document.createEvent('Event');
            event.initEvent('error', false, false);
            script.dispatchEvent(event);
          }
          return Promise.reject(e);
        });
      }
      else if (script.type === 'systemjs-importmap') {
        script.sp = true;
        var fetchPromise = script.src ? fetch(script.src, { integrity: script.integrity }).then(function (res) {
          if (!res.ok)
            throw Error( res.status );
          return res.text();
        }).catch(function (err) {
          err.message = errMsg('W4',  script.src ) + '\n' + err.message;
          console.warn(err);
          if (typeof script.onerror === 'function') {
              script.onerror();
          }
          return '{}';
        }) : script.innerHTML;
        importMapPromise = importMapPromise.then(function () {
          return fetchPromise;
        }).then(function (text) {
          extendImportMap(importMap, text, script.src || baseUrl);
        });
      }
    });
  }

  function extendImportMap (importMap, newMapText, newMapUrl) {
    var newMap = {};
    try {
      newMap = JSON.parse(newMapText);
    } catch (err) {
      console.warn(Error(( errMsg('W5')  )));
    }
    resolveAndComposeImportMap(newMap, newMapUrl, importMap);
  }

  /*
   * Script instantiation loading
   */

  if (hasDocument) {
    window.addEventListener('error', function (evt) {
      lastWindowErrorUrl = evt.filename;
      lastWindowError = evt.error;
    });
    var baseOrigin = location.origin;
  }

  systemJSPrototype.createScript = function (url) {
    var script = document.createElement('script');
    script.async = true;
    // Only add cross origin for actual cross origin
    // this is because Safari triggers for all
    // - https://bugs.webkit.org/show_bug.cgi?id=171566
    if (url.indexOf(baseOrigin + '/'))
      script.crossOrigin = 'anonymous';
    var integrity = importMap.integrity[url];
    if (integrity)
      script.integrity = integrity;
    script.src = url;
    return script;
  };

  // Auto imports -> script tags can be inlined directly for load phase
  var lastAutoImportDeps, lastAutoImportTimeout;
  var autoImportCandidates = {};
  var systemRegister = systemJSPrototype.register;
  var inlineScriptCount = 0;
  systemJSPrototype.register = function (deps, declare, autoUrl) {
    if (hasDocument && document.readyState === 'loading' && typeof deps !== 'string') {
      var scripts = document.querySelectorAll('script[src]');
      var lastScript = scripts[scripts.length - 1];
      var lastAutoImportUrl
      lastAutoImportDeps = deps;
      if (lastScript && lastScript.src) {
        lastAutoImportUrl = lastScript.src;
      }
      else if (autoUrl) {
        lastAutoImportUrl = autoUrl
      }
      else {
        inlineScriptCount++
        lastAutoImportUrl = document.location.href + "__inline_script__" + inlineScriptCount;
      }
      // if this is already a System load, then the instantiate has already begun
      // so this re-import has no consequence
      var loader = this;
      lastAutoImportTimeout = setTimeout(function () {
        autoImportCandidates[lastAutoImportUrl] = [deps, declare];
        loader.import(lastAutoImportUrl);
      });
    }
    else {
      lastAutoImportDeps = undefined;
    }
    return systemRegister.call(this, deps, declare);
  };

  var lastWindowErrorUrl, lastWindowError;
  systemJSPrototype.instantiate = function (url, firstParentUrl) {
    var autoImportRegistration = autoImportCandidates[url];
    if (autoImportRegistration) {
      delete autoImportCandidates[url];
      return autoImportRegistration;
    }
    var loader = this;
    return Promise.resolve(systemJSPrototype.createScript(url)).then(function (script) {
      return new Promise(function (resolve, reject) {
        script.addEventListener('error', function () {
          reject(Error(errMsg(3,  [url, firstParentUrl].join(', ') )));
        });
        script.addEventListener('load', function () {
          document.head.removeChild(script);
          // Note that if an error occurs that isn't caught by this if statement,
          // that getRegister will return null and a "did not instantiate" error will be thrown.
          if (lastWindowErrorUrl === url) {
            reject(lastWindowError);
          }
          else {
            var register = loader.getRegister(url);
            // Clear any auto import registration for dynamic import scripts during load
            if (register && register[0] === lastAutoImportDeps)
              clearTimeout(lastAutoImportTimeout);
            resolve(register);
          }
        });
        document.head.appendChild(script);
      });
    });
  };

  /*
   * Fetch loader, sets up shouldFetch and fetch hooks
   */
  systemJSPrototype.shouldFetch = function () {
    return false;
  };
  if (typeof fetch !== 'undefined')
    systemJSPrototype.fetch = fetch;

  var instantiate = systemJSPrototype.instantiate;
  var jsContentTypeRegEx = /^(text|application)\/(x-)?javascript(;|$)/;
  systemJSPrototype.instantiate = function (url, parent) {
    var loader = this;
    if (!this.shouldFetch(url))
      return instantiate.apply(this, arguments);
    return this.fetch(url, {
      credentials: 'same-origin',
      integrity: importMap.integrity[url]
    })
    .then(function (res) {
      if (!res.ok)
        throw Error(errMsg(7,  [res.status, res.statusText, url, parent].join(', ') ));
      var contentType = res.headers.get('content-type');
      if (!contentType || !jsContentTypeRegEx.test(contentType))
        throw Error(errMsg(4,  contentType ));
      return res.text().then(function (source) {
        if (source.indexOf('//# sourceURL=') < 0)
          source += '\n//# sourceURL=' + url;
        (0, eval)(source);
        return loader.getRegister(url);
      });
    });
  };

  systemJSPrototype.resolve = function (id, parentUrl) {
    parentUrl = parentUrl || !true  || baseUrl;
    return resolveImportMap(( importMap), resolveIfNotPlainOrUrl(id, parentUrl) || id, parentUrl) || throwUnresolved(id, parentUrl);
  };

  function throwUnresolved (id, parentUrl) {
    throw Error(errMsg(8,  [id, parentUrl].join(', ') ));
  }

  var systemInstantiate = systemJSPrototype.instantiate;
  systemJSPrototype.instantiate = function (url, firstParentUrl) {
    var preloads = ( importMap).depcache[url];
    if (preloads) {
      for (var i = 0; i < preloads.length; i++)
        getOrCreateLoad(this, this.resolve(preloads[i], url), url);
    }
    return systemInstantiate.call(this, url, firstParentUrl);
  };

  /*
   * Supports loading System.register in workers
   */

  if (hasSelf && typeof importScripts === 'function')
    systemJSPrototype.instantiate = function (url) {
      var loader = this;
      return Promise.resolve().then(function () {
        importScripts(url);
        return loader.getRegister(url);
      });
    };

}());

(function(){
  var envGlobal = typeof self !== 'undefined' ? self : global;
  var System = envGlobal.System;
  var register = System.register;
  var registerRegistry = Object.create(null)

  System.register = function (name, deps, declare) {
    if (typeof name !== 'string') return register.apply(this, arguments);
    var define = [deps, declare];
    return System.prepareImport().then(function () {
      var url = System.resolve(`./${name}`);
      registerRegistry[url] = define;
      return register.call(System, deps, declare, url);
    })
  };

  var instantiate = System.instantiate;
  System.instantiate = function (url, firstParentUrl) {
    var result = registerRegistry[url];

    if (result) {
      registerRegistry[url] = null;
      return result;
    } else {
      return instantiate.call(this, url, firstParentUrl);
    }
  };

  var getRegister = System.getRegister;
  System.getRegister = function (url) {
    // Calling getRegister() because other extras need to know it was called so they can perform side effects
    var register = getRegister.call(this, url);
    var result = registerRegistry[url] || register;
    return result;
  };
}());</script>
      <script type="systemjs-importmap">
{
  "imports": {
    "./assets/app_loader.css": "./assets/app_loader-4f96cbab.css",
    "./assets/app.css": "./assets/app-648bc845.css",
    "./assets/logo.png": "./assets/logo-25e95a00.png",
    "./app_loader.js": "./app_loader-7592728e.js",
    "./app.js": "./app-cb7cd5c8.js",
    "./boot.js": "./boot-4f2a37bc.js",
    "./dev_ribbon.js": "./dev_ribbon-a0f6ad36.js"
  }
}</script>
    <!--
      Tell browser to start fetching theses ressources right now:
      - The font
      - CSS and JS used to load the app
      - CSS and JS of the app
    -->
    <link rel="preload" href="assets/roboto_v27_latin_regular-cc46322d.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="preload" href="assets/app_loader-4f96cbab.css" as="style">
    <link rel="preload" href="app_loader-7592728e.js" as="script">
    <link rel="preload" href="assets/app-648bc845.css" as="style">
    <link rel="preload" href="app-cb7cd5c8.js" as="script">
  </head>

  <body>
    <!--
      Displaying a message when JavaScript is disabled
    -->
    <noscript>
      <h1>JavaScript is required</h1>
      <p>This page needs JavaScript to run but JavaScript is not available</p>
    </noscript>
    <!--
      Displaying a message when browser is not supported
      - "browser_support_detection.js" sets display block when browser is not supported.
      - When browser is not supported, the application won't try to boot.
    -->
    <div id="browser_not_supported" style="display: none">
      <h1>Browser not supported</h1>
      <p>Please update your internet browser or try with an other one</p>
    </div>
    <script>/*
 * This file is inlined in the HTML file by [data-jsenv-force-inline]
 * Responsabilities:
 * - Set window.browserIsSupported boolean
 * - Display #browser_not_supported div when browser is not supported
 * This file will be executed as such in every browsers. It will just be minified.
 * -> The JS used must be as compatible as possible (no const, no arrow function etc)
 */
var userAgent = window.navigator.userAgent;

function browserIsSupported() {
  var isIE = typeof document.documentMode !== "undefined";

  if (isIE) {
    return false;
  }

  var chromeVersion = versionFromUserAgent(/(?:chrome|chromium|crios|crmo)\/(\d+)/i);

  if (chromeVersion && chromeVersion < 55) {
    return false;
  }

  var edgeVersion = versionFromUserAgent(/(?:edge|edgea|edgios)\/(\d+)/i, userAgent);

  if (edgeVersion && edgeVersion < 14) {
    return false;
  }

  var firefoxVersion = versionFromUserAgent(/(?:firefox|iceweasel|fxios)[\s/](\d+)/i);

  if (firefoxVersion && firefoxVersion < 52) {
    return false;
  }

  var safariVersion = !chromeVersion && /safari|applewebkit/i.test(userAgent) ? versionFromUserAgent(/version\/(\d+)/i) : undefined;

  if (safariVersion && safariVersion < 11) {
    return false;
  }

  return true;
}

function versionFromUserAgent(regexp) {
  var match = userAgent.match(regexp);
  if (!match || match.length === 0) return undefined;
  var firstMatch = match[1];
  var version = parseInt(firstMatch);
  return version;
}

window.browserIsSupported = browserIsSupported();

if (!window.browserIsSupported) {
  document.getElementById("browser_not_supported").style.display = "block";
}
//# sourceMappingURL=assets/browser_support_detection.js-fc1e120d.map</script>
    <!--
      Booting the application
      - <div id="app"> is hidden until [data-booting] is removed by app_loader.js
      - <div id="splashscreen"> is displayed when:
        - Network is slow, so HTML is slow to fetch "app_loader.js"
        - Error while fetching, parsing or executing "app_loader.js"
        - Application starts in less than 300ms (yes it happens thanks to long term cache)
      The code implementing this logic is configurable and visible in "boot.js"
      See https://github.com/jsenv/jsenv-template-pwa/tree/main/docs/booting#booting
    -->
    <div id="app" data-booting=""></div>
    <div id="splashscreen">
      <div id="splashscreen_logo">
        <img src="data:image/png;base64,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" width="128" height="128" alt="jsenv logo">
      </div>
      <div id="splashscreen_message"></div>
      <div style="display: none">
        <div id="booting_start"></div>
        <div id="booting_is_slow">Booting...</div>
        <div id="booting_error">
          <p>An error occured while booting</p>
          <br>
          <details>
            <summary>See error stack</summary>
            <pre id="boot_runtime_error_stack">${errorStack}</pre>
          </details>
        </div>
      </div>
    </div>
    <script>System.register([], (function (exports, module) {
  'use strict';
  return {
    execute: (async function () {

      /*
       * This file is inlined in the HTML file by [data-jsenv-force-inline]
       * Responsabilities:
       * - inject the dev ribbon in development mode
       * - Dynamic import of "app_loader.js" (fetch+parse+execute)
       *   - Catch error during the dynamic import
       *   - Display splashscreen during this dynamic import
       * - Call loadApp exported by "app_loader.js"
       *   - Provide an updateSplashscreenText
       *   - Hide splashscreen once app is ready to be displayed
       */

      function _empty() {} // When it take more than "BOOTING_SLOW"ms for loadApp to resolve or call updateSplashscreenText
      // -> splashscreen displays <div id="booting_is_slow"> content


      function _awaitIgnored(value, direct) {
        if (!direct) {
          return value && value.then ? value.then(_empty) : Promise.resolve();
        }
      }

      function _call(body, then, direct) {
        if (direct) {
          return then ? then(body()) : body();
        }

        try {
          var result = Promise.resolve(body());
          return then ? result.then(then) : result;
        } catch (e) {
          return Promise.reject(e);
        }
      }

      function _invoke(body, then) {
        var result = body();

        if (result && result.then) {
          return result.then(then);
        }

        return then(result);
      }

      function _await(value, then, direct) {
        if (direct) {
          return then ? then(value) : value;
        }

        if (!value || !value.then) {
          value = Promise.resolve(value);
        }

        return then ? value.then(then) : value;
      }

      function _catch(body, recover) {
        try {
          var result = body();
        } catch (e) {
          return recover(e);
        }

        if (result && result.then) {
          return result.then(void 0, recover);
        }

        return result;
      }

      function _async(f) {
        return function () {
          for (var args = [], i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }

          try {
            return Promise.resolve(f.apply(this, args));
          } catch (e) {
            return Promise.reject(e);
          }
        };
      }

      {
        const _await$import = await module.import('./dev_ribbon.js'),
              injectDevRibbon = _await$import.injectDevRibbon;

        injectDevRibbon();
      }

      const BOOTING_SLOW = 2500; // When it takes less than "SPLASHIN_DELAY"ms for loadApp to resolve
      // -> we won't even show the splashscreen (happens on user second visit because everything is in browser cache)

      const SPLASHIN_DELAY = 300; // When less than "SPLASHOUT_MIN_INTERVAL"ms have ellapsed since splashin animation started
      // -> code ensures "SPLASHOUT_MIN_INTERVAL"ms ellapses before playing the splashout animation
      // This is to prevent a disturbing blink when loadApp resolves shortly after splashin animation

      const SPLASHOUT_MIN_INTERVAL = 650;
      const appNode = document.querySelector("#app");
      const splashscreenNode = document.querySelector("#splashscreen");
      const BOOTING_START = "booting_start";
      const BOOTING_IS_SLOW = "booting_is_slow";
      const BOOTING_ERROR = "booting_error";

      const boot = _async(function () {
        {
          performance.measure("booting app");
        }

        const bootStartMs = Date.now();
        let splashIsVisible = false;

        const splashin = () => {
          splashscreenNode.setAttribute("data-splashin", "");
          splashIsVisible = true;
        };

        const splashout = _async(function () {
          splashscreenNode.setAttribute("data-splashout", "");
          return _awaitIgnored(new Promise(resolve => {
            setTimeout(() => {
              splashIsVisible = false;
              resolve();
            }, 300);
          }));
        });

        const killSplashscreen = () => {
          // Here splashscreen is "killed" with display: 'none' but it could also
          // be removed from the DOM
          splashscreenNode.style.display = "none";
          splashIsVisible = false;

          {
            performance.measure("app displayed");
          }
        };

        const splashInTimeout = setTimeout(splashin, SPLASHIN_DELAY);
        const bootingIsSlowTimeout = setTimeout(() => {
          setBootingState(BOOTING_IS_SLOW);
        }, BOOTING_SLOW);
        return _catch(function () {
          setBootingState(BOOTING_START);
          return _await(module.import('./app_loader.js'), function (_ref) {
            let loadApp = _ref.loadApp;
            return _await(loadApp({
              updateSplashscreenText: message => {
                clearTimeout(bootingIsSlowTimeout);
                const splashscreenMessageNode = document.querySelector("#splashscreen_message");
                splashscreenMessageNode.innerHTML = message;
              }
            }), function () {
              clearTimeout(splashInTimeout);
              clearTimeout(bootingIsSlowTimeout);

              if (!splashIsVisible) {
                appNode.removeAttribute("data-booting"); // app was super fast to load, splashscreen was not even displayed, cool

                killSplashscreen();
                return;
              }

              const splashInMs = bootStartMs + SPLASHIN_DELAY;
              const msEllapsedSinceSplashIn = Date.now() - splashInMs;
              return _invoke(function () {
                if (msEllapsedSinceSplashIn < SPLASHOUT_MIN_INTERVAL) {
                  const msToWaitToPreventBlink = SPLASHOUT_MIN_INTERVAL - msEllapsedSinceSplashIn;
                  return _awaitIgnored(new Promise(resolve => {
                    setTimeout(resolve, msToWaitToPreventBlink);
                  }));
                }
              }, function () {
                appNode.removeAttribute("data-booting"); // Wait the end of the "splashout" animation before killing splashscreen entirely

                return _call(splashout, function () {
                  killSplashscreen();
                });
              });
            });
          });
        }, function (error) {
          clearTimeout(bootingIsSlowTimeout);
          setBootingState(BOOTING_ERROR, {
            errorStack: error.stack || "<No stack associated with this error> (Check devtools to get more info)"
          });
          throw error;
        });
      });

      const setBootingState = function setBootingState(nextBootingState) {
        let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const splashscreenMessageNode = document.querySelector("#splashscreen_message");
        splashscreenMessageNode.innerHTML = "";
        const variantModel = document.querySelector("#".concat(nextBootingState));
        const variantInstance = variantModel.cloneNode(true);
        replaceNodeVariables(variantInstance, data);
        splashscreenMessageNode.appendChild(variantInstance);
      };

      const replaceNodeVariables = (node, data) => {
        if (node.nodeName === "#text") {
          node.textContent = node.textContent.replace(/\${(\w*)}/g, (_, key) => {
            return data.hasOwnProperty(key) ? data[key] : "";
          });
          return;
        }

        Array.from(node.childNodes).forEach(node => {
          replaceNodeVariables(node, data);
        });
      };

      if (window.browserIsSupported) {
        await boot();
      }

    })
  };
}));

//# sourceMappingURL=boot-4f2a37bc.js.map</script>
    <!--
      Installing an early "beforeinstallprompt" event listener
      - We must listen to "beforeinstallprompt" as soon as possible or it could be missed.
      - The event is stored in window.beforeinstallpromptEvent to be used later
      See https://github.com/jsenv/pwa#add-to-home-screen
    -->
    <script>
      window.addEventListener(
        "beforeinstallprompt",
        (beforeinstallpromptEvent) => {
          beforeinstallpromptEvent.preventDefault()
          window.beforeinstallpromptEvent = beforeinstallpromptEvent
        },
      )
    </script>
  

</body></html>