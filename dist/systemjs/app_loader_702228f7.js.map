{
  "version": 3,
  "file": "app_loader.js",
  "sources": [
    "../../src/env_prod.js",
    "../../src/app_loader/app_loader_utils.js",
    "../../src/app_loader/app_loader.js"
  ],
  "sourcesContent": [
    "/**\n * This file is used when code imports from \"#env\"\n *\n * import { DEV } from \"#env\"\n *\n * And importmap contains \"#env\": \"./env_prod.js\" mapping\n * This happens when using \"prod.importmap\" file\n * See https://github.com/jsenv/jsenv-template-pwa/blob/main/docs/production_mode/production_mode.md#production-mode\n */\n\nexport const DEV = false\n",
    "export const loadCSSAndFonts = async (\n  cssUrl,\n  { timeout = 1000, onCssReady = () => {}, onFontsReady = () => {} } = {},\n) => {\n  const loadedPromise = (async () => {\n    try {\n      await injectCSS(cssUrl)\n      onCssReady()\n      if (onFontsReady) {\n        await document.fonts.ready\n        onFontsReady()\n      }\n    } catch (e) {\n      return\n    }\n  })()\n  return Promise.race([\n    loadedPromise,\n    new Promise((resolve) => {\n      setTimeout(resolve, timeout)\n    }),\n  ])\n}\n\nconst injectCSS = (cssUrl, { crossOrigin } = {}) => {\n  return new Promise((resolve, reject) => {\n    const link = document.createElement(\"link\")\n    link.rel = \"stylesheet\"\n    link.onload = resolve\n    link.onerror = reject\n    link.href = cssUrl\n    link.crossOrigin = crossOrigin\n    document.head.appendChild(link)\n  })\n}\n\nexport const nextIDLEPromise = window.requestIdleCallback\n  ? ({ timeout = 60 } = {}) => {\n      return new Promise((resolve) => {\n        window.requestIdleCallback(resolve, { timeout })\n      })\n    }\n  : () => {\n      return new Promise((resolve) => {\n        window.requestAnimationFrame(resolve)\n      })\n    }\n",
    "/**\n * This is where you can orchestrate the loading of your application\n */\n\nimport { DEV } from \"#env\"\nimport { loadCSSAndFonts, nextIDLEPromise } from \"./app_loader_utils.js\"\n\nexport const loadApp = async ({ updateSplashscreenText }) => {\n  if (DEV) {\n    performance.measure(`loading app`)\n  }\n\n  // try to load CSS + get the main fonts before displaying any text\n  // to avoid font swapping if possible\n  // give max 400ms for this\n  const appLoaderCssPromise = loadCSSAndFonts(\n    new URL(\"./app_loader.css\", import.meta.url),\n    {\n      timeout: 400,\n      onCssReady: () => {\n        if (DEV) {\n          performance.measure(`app_loader.css ready`)\n        }\n      },\n      onFontsReady: () => {\n        if (DEV) {\n          performance.measure(`fonts ready`)\n        }\n      },\n    },\n  )\n  // start importing app right away\n  const appPromise = importApp({\n    onJsReady: () => {\n      if (DEV) {\n        performance.measure(\"app.js ready\")\n      }\n    },\n  })\n  const appCSSPromise = loadCSSAndFonts(\n    new URL(\"../app/app.css\", import.meta.url),\n    {\n      onCssReady: () => {\n        if (DEV) {\n          performance.measure(`app.css ready`)\n        }\n      },\n    },\n  )\n\n  await appLoaderCssPromise\n  await updateSplashscreenText(`Loading banana...`)\n  if (DEV) {\n    performance.measure(`\"loading bannana...\" displayed`)\n  }\n  await new Promise((resolve) => {\n    setTimeout(resolve, 800)\n  })\n\n  updateSplashscreenText(`Loading gorilla...`)\n  if (DEV) {\n    performance.measure(`\"loading gorilla...\" displayed`)\n  }\n  await new Promise((resolve) => {\n    setTimeout(resolve, 1000)\n  })\n\n  updateSplashscreenText(`Loading the entire jungle...`)\n  if (DEV) {\n    performance.measure(`\"entire jungle...\" displayed`)\n  }\n  await new Promise((resolve) => {\n    setTimeout(resolve, 1200)\n  })\n\n  const app = await appPromise\n  if (DEV) {\n    performance.measure(`rendering app`)\n  }\n  app.render()\n  await appCSSPromise\n  // app.render() can be very expensive so we wait a bit\n  // to let navigator an opportunity to cooldown\n  // This should help to save battery power and RAM\n  await nextIDLEPromise()\n  if (DEV) {\n    performance.measure(`app rendered`)\n  }\n}\n\nconst importApp = async ({ onJsReady = () => {} }) => {\n  const app = await import(\"../app/app.js\")\n  onJsReady()\n  return app\n}\n"
  ],
  "names": [
    "DEV",
    "loadCSSAndFonts",
    "async",
    "cssUrl",
    "timeout",
    "onCssReady",
    "onFontsReady",
    "loadedPromise",
    "injectCSS",
    "document",
    "fonts",
    "ready",
    "e",
    "Promise",
    "race",
    "resolve",
    "setTimeout",
    "crossOrigin",
    "reject",
    "link",
    "createElement",
    "rel",
    "onload",
    "onerror",
    "href",
    "head",
    "appendChild",
    "nextIDLEPromise",
    "window",
    "requestIdleCallback",
    "requestAnimationFrame",
    "importApp",
    "updateSplashscreenText",
    "appLoaderCssPromise",
    "appPromise",
    "onJsReady",
    "appCSSPromise",
    "render",
    "app",
    "module"
  ],
  "mappings": "yEAUO,MAAMA,GAAM,ECVNC,EAAkBC,MAC7BC,GACEC,QAAAA,EAAU,IAAMC,WAAAA,EAAa,SAAUC,aAAAA,EAAe,UAAa,YAE/DC,EAAgB,qBAEZC,EAAUL,GAChBE,IACIC,UACIG,SAASC,MAAMC,MACrBL,KAEF,MAAOM,YARW,UAYfC,QAAQC,KAAK,CAClBP,EACA,IAAIM,SAASE,IACXC,WAAWD,EAASX,SAKpBI,EAAY,CAACL,GAAUc,YAAAA,GAAgB,KACpC,IAAIJ,SAAQ,CAACE,EAASG,WACrBC,EAAOV,SAASW,cAAc,QACpCD,EAAKE,IAAM,aACXF,EAAKG,OAASP,EACdI,EAAKI,QAAUL,EACfC,EAAKK,KAAOrB,EACZgB,EAAKF,YAAcA,EACnBR,SAASgB,KAAKC,YAAYP,MAIjBQ,EAAkBC,OAAOC,oBAClC,EAAGzB,QAAAA,EAAU,IAAO,KACX,IAAIS,SAASE,IAClBa,OAAOC,oBAAoBd,EAAS,CAAEX,QAAAA,OAG1C,IACS,IAAIS,SAASE,IAClBa,OAAOE,sBAAsBf,MC8C/BgB,gBAnFiB7B,OAAS8B,uBAAAA,YAQxBC,EAAsBhC,EAC1B,8DACA,CACEG,QAAS,IACTC,WAAY,KACNL,GAINM,aAAc,KACRN,KAOJkC,EAAaH,EAAU,CAC3BI,UAAW,SAMPC,EAAgBnC,EACpB,uDACA,CACEI,WAAY,KACNL,WAOJiC,QACAD,EAAwB,2BAIxB,IAAInB,SAASE,IACjBC,WAAWD,EAAS,QAGtBiB,EAAwB,4BAIlB,IAAInB,SAASE,IACjBC,WAAWD,EAAS,QAGtBiB,EAAwB,sCAIlB,IAAInB,SAASE,IACjBC,WAAWD,EAAS,gBAGJmB,GAIdG,eACED,QAIAT,OAMUzB,OAASiC,UAAAA,EAAY,mBAC/BG,QAAYC,SAAO,mBACzBJ,IACOG"
}